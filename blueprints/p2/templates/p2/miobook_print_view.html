<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ document.title }} - Print View</title>
    {% include 'core/partials/favicons.html' %}
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Summernote Editor CSS (for rendering rich text) -->
    <link href="https://cdn.jsdelivr.net/npm/summernote@0.8.20/dist/summernote-lite.min.css" rel="stylesheet">
    
    <style>
        @page {
            margin: 1.5cm;
            size: A4;
        }
        
        @media print {
            .no-print {
                display: none !important;
            }
            
            body {
                background: white !important;
            }
            
            .block-item {
                page-break-inside: avoid;
            }
            
            .canvas-container {
                page-break-inside: avoid;
            }
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .print-container {
            max-width: 21cm;
            margin: 0 auto;
            background: white;
            padding: 40px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        .print-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #0d1117;
        }
        
        .print-header h1 {
            color: #0d1117;
            margin: 0;
            font-size: 2em;
        }
        
        .print-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .block-item {
            margin-bottom: 40px;
            page-break-inside: avoid;
        }
        
        .block-header {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 15px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .note-content {
            border-left: 4px solid #238be6;
            padding-left: 20px;
            padding-top: 10px;
            padding-bottom: 10px;
            margin: 10px 0;
            background: #f8f9fa;
            border-radius: 0 4px 4px 0;
        }
        
        .note-content img {
            max-width: 100%;
            height: auto;
            margin: 10px 0;
        }
        
        .note-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        
        .note-content table td,
        .note-content table th {
            border: 1px solid #ddd;
            padding: 8px;
        }
        
        .note-content table th {
            background: #f0f0f0;
            font-weight: 600;
        }
        
        .board-content {
            border: 1px solid #ddd;
            padding: 20px;
            background: #fafafa;
            border-radius: 4px;
        }
        
        .board-render {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .board-page-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #444;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .board-page canvas {
            width: 100%;
            height: auto;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            background: #ffffff;
        }

        .canvas-container {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .canvas-container canvas {
            max-width: 100%;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .sticky-notes-section {
            margin-top: 20px;
        }
        
        .sticky-note {
            background: #fff9c4;
            border: 1px solid #f9a825;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }
        
        .sticky-note::before {
            content: 'üìå';
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 1.2em;
        }
        
        .sticky-note-content {
            padding-left: 30px;
        }
    </style>
</head>
<body>
    <!-- Print Controls (hidden when printing) -->
    <div class="print-controls no-print">
        {% if public_view and current_user.is_authenticated %}
        <button class="btn btn-info btn-sm mb-2 btn-copy-public" data-file-id="{{ document.id }}" data-file-type="file">
            <i class="fas fa-copy"></i> Copy to My Profile
        </button>
        {% endif %}
        <a href="javascript:history.back()" class="btn btn-secondary btn-sm mb-2 d-block">
            <i class="fas fa-arrow-left"></i> Back
        </a>
        <button class="btn btn-primary btn-sm mb-2" onclick="window.print()">
            <i class="fas fa-print"></i> Print / Save as PDF
        </button>
        <button class="btn btn-secondary btn-sm" onclick="window.close()">
            <i class="fas fa-times"></i> Close
        </button>
        <div class="mt-2 text-muted" style="font-size: 0.8em;">
            Use Ctrl+P or Cmd+P<br>
            Select "Save as PDF"
        </div>
    </div>

    <!-- Printable Content -->
    <div class="print-container">
        <div class="print-header">
            <h1>{{ document.title }}</h1>
        </div>

        <div id="printContent">
            {% for block in content_blocks %}
                {% if block.type == 'note' %}
                <div class="block-item">
                    <div class="block-header">üìù Note Block #{{ loop.index }}</div>
                    <div class="note-content">
                        {{ block.content|safe }}
                    </div>
                </div>
                
                {% elif block.type in ['board', 'board-iframe'] %}
                <div class="block-item" data-block-type="{{ block.type }}" data-block-index="{{ loop.index0 }}">
                    <div class="block-header">üé® Whiteboard Block #{{ loop.index }}</div>
                    <div class="board-content">
                        <div class="canvas-container" id="canvas-container-{{ loop.index0 }}">
                            <div class="board-render" id="board-render-{{ loop.index0 }}">
                                <p class="text-muted"><em>Preparing board preview‚Ä¶</em></p>
                            </div>
                        </div>
                        <div class="sticky-notes-section" id="sticky-notes-{{ loop.index0 }}"></div>
                    </div>
                </div>
                {% endif %}
            {% endfor %}
        </div>
    </div>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const contentBlocks = {{ content_blocks|tojson }};
            const renderTasks = [];

            contentBlocks.forEach((block, index) => {
                if (block.type === 'board' || block.type === 'board-iframe') {
                    const task = renderBoardBlock(block, index);
                    if (task) {
                        renderTasks.push(task);
                    }
                }
            });

            Promise.all(renderTasks)
                .then(() => {
                    console.log('[Print View] Board rendering complete');
                })
                .catch((err) => {
                    console.error('[Print View] Board rendering encountered an error', err);
                });
        });

        function renderBoardBlock(block, index) {
            const container = document.getElementById(`board-render-${index}`);
            const stickySection = document.getElementById(`sticky-notes-${index}`);

            if (!container) {
                return null;
            }

            container.innerHTML = '';

            if (block.type === 'board') {
                const content = block.content || '';

                if (typeof content === 'string' && content.startsWith('data:image')) {
                    const img = document.createElement('img');
                    img.src = content;
                    img.alt = 'Whiteboard snapshot';
                    img.style.maxWidth = '100%';
                    img.style.height = 'auto';
                    img.style.border = '1px solid #e0e0e0';
                    img.style.borderRadius = '6px';
                    img.style.boxShadow = '0 2px 6px rgba(0,0,0,0.08)';
                    container.appendChild(img);

                    if (stickySection) {
                        stickySection.style.display = 'none';
                    }

                    return Promise.resolve();
                }

                try {
                    const parsed = typeof content === 'string' ? JSON.parse(content) : content;
                    return renderStructuredBoard(parsed, container, stickySection);
                } catch (err) {
                    console.error('[Print View] Failed to parse legacy board content', err);
                    container.innerHTML = '<p class="text-muted"><em>Board content could not be rendered.</em></p>';
                    if (stickySection) {
                        stickySection.style.display = 'none';
                    }
                    return Promise.resolve();
                }
            }

            if (block.type === 'board-iframe') {
                const content = block.content || '{}';

                try {
                    const parsed = typeof content === 'string' ? JSON.parse(content) : content;
                    return renderStructuredBoard(parsed, container, stickySection);
                } catch (err) {
                    console.error('[Print View] Failed to parse embedded board content', err);
                    container.innerHTML = '<p class="text-muted"><em>Board content could not be rendered.</em></p>';
                    if (stickySection) {
                        stickySection.style.display = 'none';
                    }
                    return Promise.resolve();
                }
            }

            container.innerHTML = '<p class="text-muted"><em>Unsupported board format.</em></p>';
            if (stickySection) {
                stickySection.style.display = 'none';
            }
            return Promise.resolve();
        }

        function renderStructuredBoard(boardData, container, stickySection) {
            if (!boardData || !Array.isArray(boardData.pages)) {
                container.innerHTML = '<p class="text-muted"><em>No whiteboard content available.</em></p>';
                if (stickySection) {
                    stickySection.style.display = 'none';
                }
                return Promise.resolve();
            }

            const pagePromises = [];
            const canvasWidth = boardData.canvasWidth || 1600;
            const canvasHeight = boardData.canvasHeight || 1000;

            boardData.pages.forEach((page, pageIdx) => {
                const pageWrapper = document.createElement('div');
                pageWrapper.className = 'board-page';

                if (boardData.pages.length > 1) {
                    const title = document.createElement('div');
                    title.className = 'board-page-title';
                    title.textContent = `Page ${pageIdx + 1}`;
                    pageWrapper.appendChild(title);
                }

                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                canvas.className = 'board-page-canvas';
                pageWrapper.appendChild(canvas);
                container.appendChild(pageWrapper);

                pagePromises.push(drawBoardPage(canvas, page));
            });

            if (stickySection) {
                stickySection.style.display = 'none';
            }

            return Promise.all(pagePromises);
        }

        function drawBoardPage(canvas, page) {
            if (!canvas || !page) {
                return Promise.resolve();
            }

            const ctx = canvas.getContext('2d');
            ctx.save();
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            const objects = Array.isArray(page.objects) ? page.objects : [];
            const drawPromises = objects.map((obj) => drawBoardObject(ctx, obj));
            return Promise.all(drawPromises);
        }

        function drawBoardObject(ctx, obj) {
            if (!obj) {
                return Promise.resolve();
            }

            const type = obj.type;
            const props = obj.props || obj;

            if (type === 'stroke') {
                drawStroke(ctx, props);
                return Promise.resolve();
            }

            if (type === 'text') {
                drawText(ctx, props);
                return Promise.resolve();
            }

            if (type === 'image') {
                return drawImage(ctx, props);
            }

            // Gracefully ignore unsupported object types
            return Promise.resolve();
        }

        function drawStroke(ctx, props) {
            const color = props.color || '#000000';
            const size = props.size || 2;
            const path = Array.isArray(props.path) ? props.path : [];
            const strokeType = props.strokeType || 'path';
            const transparency = props.transparency;

            if (!path.length) {
                return;
            }

            ctx.save();
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = color;
            ctx.lineWidth = size;

            if (strokeType === 'marker') {
                ctx.globalAlpha = transparency != null ? transparency : 0.6;
            } else if (strokeType === 'highlighter') {
                ctx.globalAlpha = transparency != null ? transparency : 0.4;
            }

            ctx.beginPath();

            if (strokeType === 'rectangle' && path.length >= 2) {
                const start = path[0];
                const end = path[1];
                const x = Math.min(start.x, end.x);
                const y = Math.min(start.y, end.y);
                const w = Math.abs(end.x - start.x);
                const h = Math.abs(end.y - start.y);
                ctx.rect(x, y, w, h);
            } else if (strokeType === 'arrow' && path.length >= 2) {
                drawArrow(ctx, path[0], path[1], size);
            } else if (strokeType === 'roundedRectangle' && path.length >= 2) {
                drawRoundedRectangle(ctx, path[0], path[1], size);
            } else if (strokeType === 'decision' && path.length >= 2) {
                drawDecision(ctx, path[0], path[1]);
            } else if (strokeType === 'inputOutput' && path.length >= 2) {
                drawInputOutput(ctx, path[0], path[1]);
            } else if (strokeType === 'connector' && path.length >= 2) {
                drawConnector(ctx, path[0], path[1]);
            } else {
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i += 1) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
            }

            ctx.stroke();
            ctx.restore();
        }

        function drawArrow(ctx, start, end, size) {
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();

            const angle = Math.atan2(end.y - start.y, end.x - start.x);
            const length = size * 3;
            const arrowAngle = Math.PI / 6;

            ctx.beginPath();
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(
                end.x - length * Math.cos(angle - arrowAngle),
                end.y - length * Math.sin(angle - arrowAngle)
            );
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(
                end.x - length * Math.cos(angle + arrowAngle),
                end.y - length * Math.sin(angle + arrowAngle)
            );
            ctx.stroke();
        }

        function drawRoundedRectangle(ctx, start, end, size) {
            const x = Math.min(start.x, end.x);
            const y = Math.min(start.y, end.y);
            const w = Math.abs(end.x - start.x);
            const h = Math.abs(end.y - start.y);
            const radius = Math.min(size * 2, Math.min(w, h) / 4);

            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
            ctx.lineTo(x + radius, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function drawDecision(ctx, start, end) {
            const x = Math.min(start.x, end.x);
            const y = Math.min(start.y, end.y);
            const w = Math.abs(end.x - start.x);
            const h = Math.abs(end.y - start.y);
            const centerX = x + w / 2;
            const centerY = y + h / 2;

            ctx.beginPath();
            ctx.moveTo(centerX, y);
            ctx.lineTo(x + w, centerY);
            ctx.lineTo(centerX, y + h);
            ctx.lineTo(x, centerY);
            ctx.closePath();
        }

        function drawInputOutput(ctx, start, end) {
            const x = Math.min(start.x, end.x);
            const y = Math.min(start.y, end.y);
            const w = Math.abs(end.x - start.x);
            const h = Math.abs(end.y - start.y);
            const skew = w * 0.2;

            ctx.beginPath();
            ctx.moveTo(x + skew, y);
            ctx.lineTo(x + w, y);
            ctx.lineTo(x + w - skew, y + h);
            ctx.lineTo(x, y + h);
            ctx.closePath();
        }

        function drawConnector(ctx, start, end) {
            const x = Math.min(start.x, end.x);
            const y = Math.min(start.y, end.y);
            const w = Math.abs(end.x - start.x);
            const h = Math.abs(end.y - start.y);
            const diameter = Math.min(w, h);
            const radius = diameter / 2;
            const centerX = x + w / 2;
            const centerY = y + h / 2;

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.closePath();
        }

        function drawText(ctx, props) {
            const text = props.text || '';
            if (!text) {
                return;
            }

            const fontSize = props.fontSize || 24;
            const color = props.color || '#000000';
            const x = props.x || 0;
            const y = props.y || 0;
            const rotation = props.rotation || 0;
            const maxWordsPerLine = props.maxWordsPerLine || 12;

            ctx.save();
            ctx.font = `${fontSize}px sans-serif`;
            ctx.fillStyle = color;
            ctx.textBaseline = 'alphabetic';

            const lines = wrapTextByWords(text, maxWordsPerLine);
            ctx.translate(x, y);
            if (rotation) {
                ctx.rotate(rotation);
            }

            lines.forEach((line, idx) => {
                ctx.fillText(line, 0, idx * fontSize * 1.2);
            });

            ctx.restore();
        }

        function wrapTextByWords(text, maxWordsPerLine) {
            if (!text) {
                return [];
            }

            const words = text.split(/\s+/).filter(Boolean);
            const lines = [];
            let current = [];

            words.forEach((word) => {
                current.push(word);
                if (current.length >= maxWordsPerLine) {
                    lines.push(current.join(' '));
                    current = [];
                }
            });

            if (current.length) {
                lines.push(current.join(' '));
            }

            return lines.length ? lines : [text];
        }

        function drawImage(ctx, props) {
            return new Promise((resolve) => {
                const src = props.src || props.dataUrl || '';
                if (!src) {
                    resolve();
                    return;
                }

                const img = new Image();
                img.crossOrigin = 'anonymous';

                img.onload = function handleLoad() {
                    ctx.save();
                    const x = props.x || 0;
                    const y = props.y || 0;
                    const w = props.w || img.width;
                    const h = props.h || img.height;
                    const rotation = props.rotation || 0;

                    if (rotation) {
                        ctx.translate(x + w / 2, y + h / 2);
                        ctx.rotate(rotation);
                        ctx.drawImage(img, -w / 2, -h / 2, w, h);
                    } else {
                        ctx.drawImage(img, x, y, w, h);
                    }

                    ctx.restore();
                    resolve();
                };

                img.onerror = function handleError() {
                    resolve();
                };

                img.src = src;
            });
        }
    </script>
    
    <script>
      // Copy to profile functionality
      document.querySelectorAll('.btn-copy-public').forEach(btn => {
        btn.addEventListener('click', function() {
          const fileId = btn.dataset.fileId;
          btn.disabled = true;
          btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Copying...';
          
          fetch('/folders/public/copy/file/' + fileId, { method: 'POST' })
            .then(r => r.json())
            .then(data => {
              if (data.success && data.new_id) {
                window.location.href = '/p2/files/' + data.new_id + '/edit';
              } else {
                alert('Copy failed: ' + (data.message || 'Unknown error'));
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-copy"></i> Copy to My Profile';
              }
            })
            .catch(err => {
              console.error(err);
              alert('Copy failed');
              btn.disabled = false;
              btn.innerHTML = '<i class="fas fa-copy"></i> Copy to My Profile';
            });
        });
      });
    </script>
</body>
</html>
