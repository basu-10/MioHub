<!--
ctrl + e to insert page at that location ‚úì IMPLEMENTED
delete to delete selected elements ‚úì IMPLEMENTED
ctrl +z to undo ‚úì IMPLEMENTED
ctrl +y to redo ‚úì IMPLEMENTED
ctrl +t to insert text ‚úì IMPLEMENTED (Ctrl+Shift+T or Alt+T)
ctrl +i to insert image ‚úì IMPLEMENTED
ctrl +s to save ‚úì IMPLEMENTED (with success modal)
copy paste across pages!!!!!!!!!! ‚úì IMPLEMENTED
ctrl + click to add/remove from selection
highlikghter tool ‚úì IMPLEMENTED
multi select with rectangle tool ‚úì IMPLEMENTED
paste across pages ‚úì IMPLEMENTED
memory for each tool's color and size ‚úì IMPLEMENTED
color palette selection ‚úì IMPLEMENTED
text settings: max lines per page, max words per line ‚úì IMPLEMENTED
text editing on double click ‚úì IMPLEMENTED
right click anywhere to paste at that locaiton ‚úì IMPLEMENTED
nicer design with 2 lines of toolbar ‚úì IMPLEMENTED
copy once, multiple paste ‚úì IMPLEMENTED
CROP in modal with resizable rectangle ‚úì IMPLEMENTED
clipboard: can copy from os clipbvoard for images and text ‚úì IMPLEMENTED
move around objects with arrow keys ‚úì IMPLEMENTED
move around objects with arrow keys + shift for faster ‚úì IMPLEMENTED
flowcsharting tools with memory for color!! ‚úì IMPLEMENTED
layers and object list!! ‚úì IMPLEMENTED
with layers, bring to front, send to back, layer up, layer down ‚úì IMPLEMENTED
with tooltips on all buttons ‚úì IMPLEMENTED
with keyboard shortcuts modal ‚úì IMPLEMENTED


to implement:
shift + drag to constrain aspect ratio when resizing ‚úì IMPLEMENTED

shift + line = straight line

under settings:
page reordering

paste text + image from web with text + image embedings

write text on canvas not modal

-->



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MioPages - Multi Page Whiteboard</title>

<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<link rel="stylesheet" href="{{ url_for('static', filename='css/theme_colors_carbon_teal.css') }}">
<!-- Whiteboard(Miopage) Modules -->
<script src="{{ url_for('p2_bp.static', filename='js/whiteboard_shapes.js') }}"></script>
<script src="{{ url_for('p2_bp.static', filename='js/whiteboard_textboxes.js') }}"></script>

<script>

{% if public_view %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.btn-copy-public').forEach(function(btn) {
      btn.addEventListener('click', function() {
        const boardId = btn.dataset.boardId;
        btn.disabled = true;
        btn.textContent = 'Copying...';

        fetch('/folders/public/copy/board/' + boardId, { method: 'POST' })
          .then(r => r.json())
          .then(data => {
            if (data.success && data.new_id) {
              window.location.href = '/boards/' + data.new_id + '/edit';
            } else {
              alert('Copy failed: ' + (data.message || 'Unknown error'));
              btn.disabled = false;
              btn.innerHTML = '<i class="material-icons" style="font-size: 18px;">content_copy</i> Copy to My Profile';
            }
          })
          .catch(err => {
            console.error(err);
            alert('Copy failed');
            btn.disabled = false;
            btn.innerHTML = '<i class="material-icons" style="font-size: 18px;">content_copy</i> Copy to My Profile';
          });
      });
    });
  });
</script>
{% endif %}
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sf': ['-apple-system', 'BlinkMacSystemFont', 'SF Pro Display', 'Segoe UI', 'sans-serif']
                    },
                    colors: {
                        'apple-blue': '#007AFF',
                        'apple-gray': {
                            50: '#F2F2F7',
                            100: '#E5E5EA',
                            200: '#D1D1D6',
                            300: '#C7C7CC',
                            400: '#AEAEB2',
                            500: '#8E8E93',
                            600: '#636366',
                            700: '#48484A',
                            800: '#3A3A3C',
                            900: '#1C1C1E'
                        }
                    },
                    backdropBlur: {
                        'xs': '2px'
                    }
                }
            }
        }
    </script>

    <style>
        .palette-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #e5e5ea;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .palette-color:hover {
            transform: scale(1.1);
            border-color: #007AFF;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        
        .palette-color.active {
            border-color: #007AFF;
            border-width: 3px;
            box-shadow: 0 0 0 1px #007AFF;
        }

        /* Collapsible sections styling */
        details {
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            margin-bottom: 8px;
        }

        details summary {
            padding: 8px 12px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 6px;
            transition: all 0.2s ease;
            user-select: none;
        }

        details summary:hover {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
        }

        details[open] summary {
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: 1px solid #e5e7eb;
        }

        details summary::marker {
            content: "‚ñ∂";
            color: #007AFF;
            font-size: 12px;
            margin-right: 8px;
        }

        details[open] summary::marker {
            content: "‚ñº";
        }

        details div {
            padding: 12px 16px;
            background: white;
            border-radius: 0 0 6px 6px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Preview mode - hide all toolbars and UI elements */
        body.preview-mode > div:first-of-type {
            display: none !important;
        }
        
    body.preview-mode #canvas-container {
      margin-top: 0 !important;
    }

    body.preview-mode #page-controls-container {
      display: none !important;
    }

    {% if public_view %}
    /* Public view: hide editing chrome and block pointer edits */
    body.public-board-view #board-toolbar { display: none !important; }
    body.public-board-view #board-canvas { pointer-events: none; }
    body.public-board-view #statusbar { display: none !important; }
    body.public-board-view .board { margin-top: 16px; height: calc(100vh - 32px - 32px); }
    body.public-board-view .public-board-header { position: relative; z-index: 5; }
    {% endif %}
    </style>


    <link rel="stylesheet" href="{{ url_for('static', filename='css/new_board_v3.css') }}">
</head>
<body class="{% if public_view %}public-board-view{% endif %}" style="height: 100vh; overflow: hidden; display: flex; flex-direction: column;">
    <!-- Include Compact Toolbar -->
    {% include 'p2/board_toolbar_partial.html' %}

    {% if public_view %}
    <div class="public-board-header w-full px-6 pt-6 text-gray-200">
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg flex flex-col gap-3">
        <div class="flex items-center justify-between">
          <a href="javascript:history.back()" class="text-gray-400 hover:text-gray-100 inline-flex items-center">
            <i class="material-icons mr-1">arrow_back</i> Back
          </a>
          {% if current_user.is_authenticated %}
          <button class="btn btn-copy-public px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md inline-flex items-center gap-2" data-board-id="{{ file.id }}" data-item-type="board">
            <i class="material-icons" style="font-size: 18px;">content_copy</i>
            Copy to My Profile
          </button>
          {% endif %}
        </div>
        <div class="flex items-start justify-between flex-wrap gap-3">
          <div>
            <h1 class="text-2xl text-gray-100 font-semibold">{{ file.title or '(untitled)' }}</h1>
            <p class="text-gray-300 text-sm">By {{ file.owner.username if file.owner else 'Unknown user' }}{% if file.created_at %} ‚Ä¢ {{ file.created_at.strftime('%Y-%m-%d') }}{% endif %}</p>
          </div>
          {% if file.is_public %}
          <span class="inline-flex items-center px-3 py-1 bg-green-600 text-white rounded-md">
            <i class="material-icons mr-1">public</i> Public
          </span>
          {% endif %}
        </div>
        {% if file.description %}
        <div class="text-gray-300 text-sm">{{ file.description }}</div>
        {% endif %}
      </div>
    </div>
    {% endif %}

    <div class="board" style="margin-top: 60px; height: calc(100vh - 60px - 40px); overflow: hidden; display: flex; justify-content: center; align-items: center; padding: 10px; background-color: #f8f9fa;">
        <div class="canvas-container" style="display: flex; justify-content: center; align-items: center; border: 3px solid #d1d5db; border-radius: 12px; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); background: white; padding: 12px; max-width: fit-content; max-height: fit-content;">
            <canvas id="board-canvas" width="1600" height="1000" style="border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); max-width: calc(100vw - 60px); max-height: calc(100vh - 120px); display: block;"></canvas>
        </div>
        
  <!-- Floating Page Controls -->
  <div id="page-controls-container" class="fixed bottom-6 right-6 z-40">
            <div class="bg-white/90 backdrop-blur-md border border-apple-gray-200 rounded-xl shadow-lg p-2 flex items-center space-x-1">
                <button id="add-page-before" title="Insert New Page Before Current Page" class="p-2 rounded-lg hover:bg-apple-gray-100 transition-colors duration-200">
                  <i class="fas fa-plus text-apple-gray-700"></i>
                </button>
                <div class="w-px h-6 bg-apple-gray-300 mx-1"></div>

              <button id="prev-page" title="Previous Page" class="p-2 rounded-lg hover:bg-apple-gray-100 transition-colors duration-200">
                    <i class="fas fa-chevron-left text-apple-gray-700"></i>
                </button>
                <div class="px-3 py-1 text-sm font-medium text-apple-gray-700 min-w-[3rem] text-center" id="page-info">1 / 1</div>
                <button id="next-page" title="Next Page" class="p-2 rounded-lg hover:bg-apple-gray-100 transition-colors duration-200">
                    <i class="fas fa-chevron-right text-apple-gray-700"></i>
                </button>
                <div class="w-px h-6 bg-apple-gray-300 mx-1"></div>
                
                <button id="add-page" title="Insert New Page After Current Page" class="p-2 rounded-lg hover:bg-apple-gray-100 transition-colors duration-200">
                    <i class="fas fa-plus text-apple-gray-700"></i>
                </button>
                <div class="w-px h-6 bg-apple-gray-300 mx-1"></div>

                <button id="delete-page" title="Delete Current Page" class="p-2 rounded-lg hover:bg-red-100 transition-colors duration-200">
                    <i class="fas fa-trash text-red-600"></i>
                </button>
            </div>
        </div>
    </div>

    <div class="statusbar" id="statusbar" style="position: fixed; bottom: 0; left: 0; right: 0; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-top: 1px solid #e5e7eb; padding: 8px 16px; font-size: 12px; color: #6b7280; z-index: 100; text-align: center;">Ready</div>

    <!-- Context Menu -->
    <div class="ctx-menu" id="ctx" style="display: none; position: fixed; background: white; border: 1px solid #d1d5db; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); padding: 4px; z-index: 2000; min-width: 140px;">
        <button data-cmd="edit-text" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Edit Text</button>
        <button data-cmd="crop" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Crop</button>
        <button data-cmd="copy" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Copy</button>
        <button data-cmd="paste" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Paste</button>
        <hr style="margin: 4px 0; border: none; border-top: 1px solid #e5e7eb;">
        <button data-cmd="duplicate" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Duplicate</button>
        <button data-cmd="layer-up" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Layer Up</button>
        <button data-cmd="layer-down" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Layer Down</button>
        <button data-cmd="front" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Bring to Front</button>
        <button data-cmd="back" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #374151;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Send to Back</button>
        <hr style="margin: 4px 0; border: none; border-top: 1px solid #e5e7eb;">
        <button data-cmd="delete" style="display: block; width: 100%; padding: 8px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 4px; font-size: 14px; color: #dc2626;" onmouseover="this.style.backgroundColor='#fee2e2'" onmouseout="this.style.backgroundColor='transparent'">Delete</button>
    </div>

    <!-- Text Editor Overlay -->
    <div class="overlay" id="text-editor-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div class="modal" style="background: white; padding: 20px; border-radius: 10px; max-width: 500px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <h3 style="margin: 0 0 15px 0; font-size: 18px; font-weight: bold;">Edit Text</h3>
            <textarea id="text-editor-textarea" placeholder="Enter your text here..." style="width: 100%; min-height: 150px; height: 150px; border: 1px solid #ddd; border-radius: 5px; padding: 10px; resize: none; font-family: inherit; box-sizing: border-box; overflow-y: hidden; max-height: 70vh;"></textarea>
            <div class="buttons" style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="text-editor-cancel" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 5px; cursor: pointer;">Cancel</button>
                <button id="text-editor-save" style="padding: 8px 16px; border: none; background: #007AFF; color: white; border-radius: 5px; cursor: pointer;">Save</button>
            </div>
        </div>
    </div>

    <!-- Crop Image Overlay -->
    <div class="overlay" id="crop-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div class="modal" style="background: white; padding: 20px; border-radius: 10px; min-width: 600px; max-width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <h3 style="margin: 0 0 15px 0; font-size: 18px; font-weight: bold;">Crop Image</h3>
            <div id="crop-container" style="position: relative; margin: 20px 0;">
                <img id="crop-image" style="max-width: 100%; max-height: 400px; display: block;" />
                <div id="crop-selection" style="position: absolute; border: 2px solid #007AFF; background: rgba(0, 122, 255, 0.1); cursor: move; box-sizing: border-box;"></div>
                <div id="crop-handles">
                    <div class="crop-handle" data-handle="nw" style="position: absolute; width: 10px; height: 10px; background: #007AFF; cursor: nw-resize;"></div>
                    <div class="crop-handle" data-handle="ne" style="position: absolute; width: 10px; height: 10px; background: #007AFF; cursor: ne-resize;"></div>
                    <div class="crop-handle" data-handle="sw" style="position: absolute; width: 10px; height: 10px; background: #007AFF; cursor: sw-resize;"></div>
                    <div class="crop-handle" data-handle="se" style="position: absolute; width: 10px; height: 10px; background: #007AFF; cursor: se-resize;"></div>
                </div>
            </div>
            <div class="buttons" style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="crop-cancel" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 5px; cursor: pointer;">Cancel</button>
                <button id="crop-save" style="padding: 8px 16px; border: none; background: #007AFF; color: white; border-radius: 5px; cursor: pointer;">Save</button>
            </div>
        </div>
    </div>

    <!-- Settings Overlay -->
    <div class="overlay" id="settings-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div class="modal" style="background: white; padding: 20px; border-radius: 10px; min-width: 400px; max-width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <h3 style="margin: 0 0 15px 0; font-size: 18px; font-weight: bold;">Settings</h3>
            
            <h4 style="margin: 15px 0 8px 0; font-size: 14px; font-weight: bold;">Color Palette</h4>
            <label style="display: block; margin-bottom: 10px;">Select Color Palette:
                <select id="color-palette-select" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px; margin-top: 5px;">
                    <option value="none">No Palette</option>
                    <option value="pastel" selected>Pastel Colors</option>
                    <option value="primary">Primary Colors</option>
                    <option value="secondary">Secondary Colors</option>
                    <option value="warm">Warm Colors</option>
                    <option value="cool">Cool Colors</option>
                </select>
            </label>
            
            <div id="palette-preview" style="margin: 10px 0; display: none;">
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Preview:</div>
                <div id="palette-preview-colors" style="display: flex; gap: 5px;"></div>
            </div>
            
            <h4 style="margin: 15px 0 8px 0; font-size: 14px; font-weight: bold;">Paste Text Settings</h4>
            <label style="display: block; margin-bottom: 8px;">Max lines per page: <input type="number" id="max-lines-per-page" min="1" max="100" value="25" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px; margin-left: 10px;"></label>
            <label style="display: block; margin-bottom: 15px;">Max words per line: <input type="number" id="max-words-per-line" min="1" max="50" value="10" style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px; margin-left: 10px;"></label>
            <div class="buttons" style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="settings-cancel" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 5px; cursor: pointer;">Cancel</button>
                <button id="settings-save" style="padding: 8px 16px; border: none; background: #007AFF; color: white; border-radius: 5px; cursor: pointer;">Save</button>
            </div>
        </div>
    </div>

    <!-- Objects/Layers Overlay -->
    <div class="overlay" id="objects-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div class="modal" style="background: white; padding: 20px; border-radius: 10px; min-width: 600px; max-width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <h3 style="margin: 0 0 15px 0; font-size: 18px; font-weight: bold;">Objects & Layers</h3>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold;">Select Layer:</label>
                <select id="layer-select" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px;">
                    <option value="all">All Layers</option>
                </select>
            </div>
            
            <div id="objects-list" style="max-height: 400px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 5px;">
                <!-- Objects will be populated here -->
            </div>
            
            <div class="buttons" style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="objects-close" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 5px; cursor: pointer;">Close</button>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Overlay -->
    <div class="overlay" id="shortcuts-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div class="modal" style="background: white; padding: 20px; border-radius: 10px; min-width: 500px; max-width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <h3 style="margin: 0 0 15px 0; font-size: 18px; font-weight: bold;">Keyboard Shortcuts</h3>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold; color: #007AFF;">Tools & Actions</h4>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Text Tool</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Ctrl+T</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Image Tool</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Ctrl+I</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Save</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Ctrl+S</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Undo</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Ctrl+Z</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Redo</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Ctrl+Y</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Insert Page</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Ctrl+E</kbd>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold; color: #007AFF;">Selection & Movement</h4>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Add/Remove from Selection</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Ctrl+Click</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Move Selected Objects</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Arrow Keys</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Move Faster</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Shift+Arrows</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Constrain Aspect Ratio</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Shift+Drag</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Delete Selected</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Delete</kbd>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>Paste at Cursor</span>
                            <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">Right Click</kbd>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007AFF;">
                <h4 style="margin: 0 0 12px 0; font-size: 14px; font-weight: bold; color: #007AFF;">Features & Tips</h4>

                <details style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #333; margin-bottom: 8px; outline: none;">üìù Text & Pasting</summary>
                    <div style="padding-left: 15px; font-size: 13px; color: #666; line-height: 1.4;">
                        <ul style="margin: 0; padding-left: 20px;">
                            <li><strong>Smart Text Breaking:</strong> Large pasted text automatically breaks across pages with configurable limits</li>
                            <li><strong>Per-Line Control:</strong> Set maximum words per line in settings</li>
                            <li><strong>Per-Page Limits:</strong> Configure maximum lines per page</li>
                            <li><strong>Double-click to Edit:</strong> Edit any text object by double-clicking</li>
                            <li><strong>Cross-Page Copy/Paste:</strong> Copy text and paste it on any page</li>
                        </ul>
                    </div>
                </details>

                <details style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #333; margin-bottom: 8px; outline: none;">üé® Tools & Customization</summary>
                    <div style="padding-left: 15px; font-size: 13px; color: #666; line-height: 1.4;">
                        <ul style="margin: 0; padding-left: 20px;">
                            <li><strong>Persistent Settings:</strong> Each tool remembers its last color and size</li>
                            <li><strong>Color Palettes:</strong> Choose from predefined color palettes or create custom ones</li>
                            <li><strong>Size Control:</strong> Adjust tool sizes with the slider or size inputs</li>
                            <li><strong>Highlighter Opacity:</strong> Adjust transparency for highlighter tool</li>
                            <li><strong>Shape Tools:</strong> Flowchart shapes with persistent color memory</li>
                        </ul>
                    </div>
                </details>

                <details style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #333; margin-bottom: 8px; outline: none;">üñºÔ∏è Images & Media</summary>
                    <div style="padding-left: 15px; font-size: 13px; color: #666; line-height: 1.4;">
                        <ul style="margin: 0; padding-left: 20px;">
                            <li><strong>Compressed Uploads:</strong> Images are automatically compressed for better performance</li>
                            <li><strong>Crop Modal:</strong> Resize and crop images with the interactive crop tool</li>
                            
                            <li><strong>Clipboard Support:</strong> Paste images directly from clipboard or web. Pictures supported.</li>
                            <li><strong>Resize Images with Shift:</strong> Hold Shift while resizing to maintain aspect ratio</li>
                        </ul>
                    </div>
                </details>

                <details style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #333; margin-bottom: 8px; outline: none;">üéØ Selection & Navigation</summary>
                    <div style="padding-left: 15px; font-size: 13px; color: #666; line-height: 1.4;">
                        <ul style="margin: 0; padding-left: 20px;">
                            <li><strong>Multi-Selection:</strong> Use rectangle select tool for selecting multiple objects</li>
                            <li><strong>Add/Remove:</strong> Ctrl+Click to add/remove individual objects from selection</li>
                            <li><strong>Arrow Key Movement:</strong> Move selected objects with arrow keys</li>
                            <li><strong>Fast Movement:</strong> Hold Shift + arrows for faster movement</li>
                            <li><strong>Right-Click Paste:</strong> Paste at cursor position with right-click</li>
                        </ul>
                    </div>
                </details>

                <details style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #333; margin-bottom: 8px; outline: none;">üìÑ Pages & Organization</summary>
                    <div style="padding-left: 15px; font-size: 13px; color: #666; line-height: 1.4;">
                        <ul style="margin: 0; padding-left: 20px;">
                            <li><strong>Multi-Page Support:</strong> Create unlimited pages for your whiteboard</li>
                            <li><strong>Page Navigation:</strong> Use prev/next buttons or left/right arrow keys</li>
                            <li><strong>Insert Pages:</strong> Use the "+" button or Ctrl+E to insert new pages after current page</li>
                           
                            <li><strong>Cross-Page Operations:</strong> Copy/paste objects between pages</li>
                        </ul>
                    </div>
                </details>

                <details style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #333; margin-bottom: 8px; outline: none;">üíæ File Operations</summary>
                    <div style="padding-left: 15px; font-size: 13px; color: #666; line-height: 1.4;">
                        <ul style="margin: 0; padding-left: 20px;">
                            <li><strong>Auto-Save:</strong> Automatically saves every 45 seconds when changes detected</li>
                            <li><strong>Unsaved Changes:</strong> Warning before leaving page with unsaved work</li>
                            <li><strong>Export Options:</strong> Export as JSON, PNG, or PDF</li>
                            <li><strong>Import Support:</strong> Import previously exported JSON files</li>
                            <li><strong>Keyboard Save:</strong> Ctrl+S for quick saving</li>
                            <li><strong>Success Notifications:</strong> Visual feedback when saves complete</li>
                        </ul>
                    </div>
                </details>
            </div>
            
            <div class="buttons" style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="shortcuts-close" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 5px; cursor: pointer;">Close</button>
            </div>
        </div>
    </div>

    <!-- Save Success Notification -->
    <div id="save-success-notification" style="display: none; position: fixed; top: 20px; right: 20px; z-index: 3000; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 250px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif; transition: all 0.3s ease;">
        <div style="display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 16px;">‚úì</span>
            <div>
                <div style="font-weight: 600; font-size: 14px; margin-bottom: 2px;">Saved Successfully!</div>
                <div id="save-success-message" style="font-size: 12px; opacity: 0.9;"></div>
            </div>
        </div>
    </div>

    <!-- Save Loading Overlay -->
    <div id="save-loading-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 4000; justify-content: center; align-items: center; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;">
        <div style="background: white; padding: 20px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); text-align: center; max-width: 300px;">
            <div style="font-size: 24px; margin-bottom: 10px;">üíæ</div>
            <div style="font-weight: 600; font-size: 16px; margin-bottom: 8px;">Saving...</div>
            <div style="font-size: 14px; color: #666; margin-bottom: 15px;">Please wait while your whiteboard is being saved.</div>
            <div style="display: inline-block; width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid #007AFF; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        </div>
    </div>

    <!-- Hidden Forms -->
<!-- Automatically route to correct Flask endpoint depending on new vs. existing board -->
<form id="save-form" action="{{ url_for('boards.edit_board', board_id=file.id) if file else url_for('boards.new_board') }}" method="POST" style="display:none;">
    <input id="title-input" name="title" value="{{ file.title if file else 'MioPage' }}">
    <input id="description-input" name="description" value="{{ file.description if file else '' }}">
    <input id="content-input" name="content">
    <input type="hidden" name="folder_id" id="folder-id-input" value="{{ file.folder_id if file else current_folder_id }}">
</form>


    <input type="file" id="importFile" accept=".json" style="display:none;" onchange="handleImportFile(event)">

    <script id="initial-board-data" type="application/json">{{ (file.content_json|tojson|safe) if file and file.content_json else 'null' }}</script>


<script>
  let rectSelecting = false;
  let rectSelectStart = null;
  let rectSelectEnd = null;
  let multiSelectedIds = new Set();

  function s(v){
    const i = document.getElementById('tool-select');
    if (i.value === v) return;
    
    // Save current tool's settings before switching
    const oldTool = i.value;
    if (oldTool && (oldTool === 'pen' || oldTool === 'marker' || oldTool === 'highlighter' || isShapeTool(oldTool))) {
      toolColors[oldTool] = color;
      toolSizes[oldTool] = size;
      if (oldTool === 'highlighter' || oldTool === 'marker') {
        toolTransparencies[oldTool] = currentTransparency;
      }
    }
    
    i.value = v;
    currentTool = v;
    
    // Update all tool buttons visual state - target buttons with data-value attribute
    Array.from(document.querySelectorAll('button[data-value]'))
        .forEach(b => {
            const isPressed = b.dataset.value === v;
            b.setAttribute('aria-pressed', String(isPressed));
            
            // Remove all existing state classes
            b.classList.remove('bg-blue-50', 'text-blue-700', 'bg-blue-100', 'text-gray-600', 'hover:bg-gray-50', 'hover:bg-blue-100');
            
            // Apply appropriate classes based on state
            if (isPressed) {
                b.classList.add('bg-blue-50', 'text-blue-700');
                // Add hover state for active button
                b.classList.add('hover:bg-blue-100');
            } else {
                b.classList.add('text-gray-600', 'hover:bg-gray-50');
            }
        });
    
    // Close shapes dropdown if a shape tool is selected
    if (isShapeTool(v)) {
      document.getElementById('shapes-dropdown').classList.add('hidden');
    }
    
    // Load tool-specific color when switching tools
    if (toolColors[v]) {
      color = toolColors[v];
      document.getElementById('color-picker').value = color;
      document.getElementById('current-tool-color').style.backgroundColor = color;
    }
    
    // Load tool-specific size when switching tools
    if (toolSizes[v]) {
      size = toolSizes[v];
      document.getElementById('size-range').value = size;
    }
    
    // Show/hide transparency control and load transparency for highlighter
    const transparencyControl = document.getElementById('transparency-control');
    if (v === 'highlighter') {
      transparencyControl.classList.remove('hidden');
      transparencyControl.classList.add('flex');
      currentTransparency = toolTransparencies[v] || 0.4;
      document.getElementById('transparency-range').value = currentTransparency;
      document.getElementById('transparency-value').textContent = Math.round(currentTransparency * 100) + '%';
    } else {
      transparencyControl.classList.add('hidden');
      transparencyControl.classList.remove('flex');
      currentTransparency = toolTransparencies[v] || 1.0;
    }
    
    i.dispatchEvent(new Event('change', { bubbles: true }));
    // Reset multi-selection state when switching tools
    if (v !== 'rect-select') {
      rectSelecting = false;
      rectSelectStart = null;
      rectSelectEnd = null;
      multiSelectedIds.clear();
      redraw();
    }
  }

  // Function to visually deselect all tools
  function deselectAllTools() {
    const i = document.getElementById('tool-select');
    i.value = ''; // Clear the tool value
    currentTool = '';
    Array.from(document.querySelectorAll('#tool-buttons button'))
        .forEach(b => {
            b.setAttribute('aria-pressed', 'false');
            b.className = 'tool-btn px-3 py-1.5 rounded-lg text-sm font-medium transition-all duration-200 bg-apple-gray-100 text-apple-gray-700 hover:bg-apple-gray-200';
        });
  }
</script>


<script>
document.addEventListener('DOMContentLoaded', function () {
  try {
    const params = new URLSearchParams(window.location.search);
    const fid = params.get('folder_id');
    const folderInput = document.getElementById('folder-id-input');
    if (folderInput && fid) folderInput.value = fid;
  } catch (e) {
    // noop
  }
});
</script>




<script>
/* =========================
   Enhanced Multi-Page Whiteboard(Miopage)
   ========================= */

/* ======= Model ======= */
const IS_PUBLIC_VIEW = {{ 'true' if public_view else 'false' }};
const DISABLE_EDITING = {{ 'true' if disable_editing else 'false' }};
const BASE_STROKE_LAYER = 0;
const BASE_OBJECT_LAYER = 0;
const MAX_CACHED_IMAGES = 50;

const canvas = document.getElementById('board-canvas');
const ctx = canvas.getContext('2d');
const statusbar = document.getElementById('statusbar');
const imageCache = new Map();

if (DISABLE_EDITING) {
  canvas.style.pointerEvents = 'none';
  if (statusbar) {
    statusbar.textContent = 'Read-only preview';
  }

  document.addEventListener('keydown', (e) => {
    const blockable = ['z', 'y', 's', 'c', 'x', 'v', 'a'];
    if (e.key === 'Delete' || e.key === 'Backspace' || (e.ctrlKey && blockable.includes(e.key.toLowerCase()))) {
      e.preventDefault();
    }
  }, { capture: true });
}

// Multi-page data structure
let pages = []; // Array of page objects: {id, objects, undoStack, redoStack}
let currentPageIndex = 0;
let nextPageId = 1;
let nextObjectId = 1;

// Auto-save and undo history configuration
const MAX_UNDO_HISTORY = 50; // Keep last 50 actions to prevent memory bloat
let hasUnsavedChanges = false;
let autoSaveTimer = null;
let isSaving = false;

// Global clipboard for copy/paste across pages
let globalClipboard = null;
let lastInternalClipboardAt = 0;
let lastOsClipboardAt = 0;
let lastOsClipboardSignature = null;
// Position where context menu was opened (for paste positioning)
let contextMenuPosition = null;
// Current mouse position for keyboard paste
let currentMousePosition = null;

// Helper function to position pasted objects at context menu location
function positionPastedObjects(objects, basePosition) {
  if (!basePosition || !objects.length) return objects;
  
  // Find the reference point (top-left most point of all objects)
  let minX = Infinity, minY = Infinity;
  objects.forEach(obj => {
    const objX = obj.props?.x || obj.x;
    const objY = obj.props?.y || obj.y;
    const objPath = obj.props?.path || obj.path || [];
    
    if (obj.type === 'image' || obj.type === 'text') {
      minX = Math.min(minX, objX);
      minY = Math.min(minY, objY);
    } else if (obj.type === 'stroke' && objPath.length > 0) {
      objPath.forEach(pt => {
        minX = Math.min(minX, pt.x);
        minY = Math.min(minY, pt.y);
      });
    }
  });
  
  // Calculate offset to move the group to the base position
  const offsetX = basePosition.x - minX;
  const offsetY = basePosition.y - minY;
  
  // Apply offset to all objects
  return objects.map(obj => {
    const clone = structuredCloneSafe(obj);
    
    if (clone.type === 'image' || clone.type === 'text') {
      if (clone.props) {
        clone.props.x = (clone.props.x || 0) + offsetX;
        clone.props.y = (clone.props.y || 0) + offsetY;
      } else {
        clone.x = (clone.x || 0) + offsetX;
        clone.y = (clone.y || 0) + offsetY;
      }
    } else if (clone.type === 'stroke') {
      const path = clone.props?.path || clone.path || [];
      const newPath = path.map(pt => ({x: pt.x + offsetX, y: pt.y + offsetY}));
      if (clone.props) {
        clone.props.path = newPath;
      } else {
        clone.path = newPath;
      }
    }
    
    return clone;
  });
}

function markInternalClipboardUpdated() {
  lastInternalClipboardAt = Date.now();
}

function updateOsClipboardSignature(signature, timestampOverride) {
  if (!signature) return;
  const nextTimestamp = timestampOverride ?? Date.now();
  if (signature !== lastOsClipboardSignature) {
    lastOsClipboardSignature = signature;
    lastOsClipboardAt = nextTimestamp;
  } else if (timestampOverride !== undefined) {
    lastOsClipboardAt = nextTimestamp;
  }
}

async function compressClipboardImage(blob) {
  const baseDataUrl = await new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = ev => resolve(ev.target.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });

  return await new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const targetPixels = 1.2 * 1000000;
      const currentPixels = img.width * img.height;
      let w = img.width;
      let h = img.height;

      if (currentPixels > targetPixels) {
        const scale = Math.sqrt(targetPixels / currentPixels);
        w = Math.round(img.width * scale);
        h = Math.round(img.height * scale);
      }

      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);

      const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
      const signature = `image:${blob.type}:${blob.size}:${w}x${h}:${compressedDataUrl.length}`;
      resolve({ dataUrl: compressedDataUrl, width: w, height: h, signature });
    };
    img.onerror = reject;
    img.src = baseDataUrl;
  });
}

async function readOsClipboardContent() {
  try {
    if (navigator.clipboard?.read) {
      const items = await navigator.clipboard.read();
      for (const item of items) {
        const imageTypes = item.types.filter(type => type.startsWith('image/'));
        if (imageTypes.length > 0) {
          const imageType = imageTypes[0];
          const blob = await item.getType(imageType);
          const compressed = await compressClipboardImage(blob);
          const candidateTimestamp = compressed.signature === lastOsClipboardSignature ? lastOsClipboardAt : Date.now();
          return { type: 'image', ...compressed, signature: compressed.signature, candidateTimestamp };
        }
      }
    }
  } catch (err) {
    console.warn('OS clipboard image read failed', err);
  }

  try {
    const text = await navigator.clipboard.readText();
    if (text) {
      const signature = `text:${text.length}:${text.substring(0, 64)}`;
      const candidateTimestamp = signature === lastOsClipboardSignature ? lastOsClipboardAt : Date.now();
      return { type: 'text', text, signature, candidateTimestamp };
    }
  } catch (err) {
    console.warn('OS clipboard text read failed', err);
  }

  return null;
}

async function pasteFromOsClipboard(osContent, basePosition) {
  if (!osContent) return false;

  if (osContent.type === 'image') {
    const startX = basePosition?.x ?? 50;
    const startY = basePosition?.y ?? 160;
    addObject({
      id: nextObjectId++,
      type: 'image',
      layer: BASE_OBJECT_LAYER,
      props: { src: osContent.dataUrl, x: startX, y: startY, w: osContent.width, h: osContent.height }
    });
    selectedId = nextObjectId - 1;
    multiSelectedIds = new Set([selectedId]);
    redraw();
    return true;
  }

  if (osContent.type === 'text') {
    const fs = parseInt(document.getElementById('text-size').value, 10) || 24;
    addTextAcrossPages(osContent.text, fs, basePosition?.x ?? 50, basePosition?.y ?? 160);
    selectedId = null;
    multiSelectedIds.clear();
    return true;
  }

  return false;
}

function pasteFromInternalClipboard(basePosition) {
  if (!globalClipboard || globalClipboard.length === 0) return false;

  const pastePosition = basePosition || { x: 100, y: 100 };
  const positionedObjects = positionPastedObjects(globalClipboard, pastePosition);
  const clones = positionedObjects.map(obj => {
    obj.id = nextObjectId++;
    return { type: 'add', object: obj };
  });

  executeCommand({ type: 'batch', commands: clones });
  multiSelectedIds = new Set(clones.map(c => c.object.id));
  selectedId = null;
  resetUIControls();
  redraw();
  return true;
}

async function handlePasteAtPosition(basePosition) {
  const osContent = await readOsClipboardContent();
  const hasInternal = !!(globalClipboard && globalClipboard.length > 0);
  const osTimestamp = osContent?.candidateTimestamp ?? 0;
  const recentlyCopiedInternally = lastInternalClipboardAt && (Date.now() - lastInternalClipboardAt < 500);
  const osIsNewer = osContent && !recentlyCopiedInternally && (!hasInternal || osTimestamp >= lastInternalClipboardAt);

  if (osIsNewer) {
    const pasted = await pasteFromOsClipboard(osContent, basePosition);
    if (pasted) {
      updateOsClipboardSignature(osContent.signature, osTimestamp);
      return true;
    }
  }

  if (hasInternal) {
    const pasted = pasteFromInternalClipboard(basePosition);
    if (pasted) return true;
  }

  if (osContent) {
    const pasted = await pasteFromOsClipboard(osContent, basePosition);
    if (pasted) {
      updateOsClipboardSignature(osContent.signature, osTimestamp);
      return true;
    }
  }

  alert('Clipboard is empty or contains unsupported content.');
  return false;
}

// Current page state (loaded from pages array)
let objects = [];
let undoStack = [];
let redoStack = [];

let currentTool = 'select';
let color = '#000000';
let size = 2;  // Default to pen size

// Tool-specific colors
let toolColors = {
  pen: '#ff0000',      // Red for pen
  marker: '#0000ff',   // Blue for marker  
  highlighter: '#ffb3d9', // Light pink for highlighter
  line: '#000000',     // Black for line
  rectangle: '#000000', // Black for rectangle
  arrow: '#000000',    // Black for arrow
  roundedRectangle: '#000000', // Black for rounded rectangle
  decision: '#000000', // Black for decision
  inputOutput: '#000000', // Black for input/output
  connector: '#000000', // Black for connector
  text: '#000000'      // Black for text
};

// Tool-specific sizes
let toolSizes = {
  pen: 2,              // Thin for pen
  marker: 5,           // Thick for marker
  highlighter: 8,      // Thick for highlighter
  line: 3,             // Medium for line
  rectangle: 3,        // Medium for rectangle
  arrow: 3,            // Medium for arrow
  roundedRectangle: 3, // Medium for rounded rectangle
  decision: 3,         // Medium for decision
  inputOutput: 3,      // Medium for input/output
  connector: 3         // Medium for connector
};

// Tool-specific transparencies
let toolTransparencies = {
  pen: 1.0,            // Opaque for pen
  marker: 0.6,         // Semi-transparent for marker
  highlighter: 0.4,    // More transparent for highlighter
  line: 1.0,           // Opaque for line
  rectangle: 1.0,      // Opaque for rectangle
  arrow: 1.0,          // Opaque for arrow
  roundedRectangle: 1.0, // Opaque for rounded rectangle
  decision: 1.0,       // Opaque for decision
  inputOutput: 1.0,    // Opaque for input/output
  connector: 1.0,      // Opaque for connector
  text: 1.0            // Opaque for text
};

// Current transparency value
let currentTransparency = 1.0;

// Color Palette Definitions
const colorPalettes = {
  pastel: {
    name: 'Pastel Colors',
    colors: ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#D4BAFF', '#FFBAE8', '#F0F0F0']
  },
  primary: {
    name: 'Primary Colors',
    colors: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#000000', '#FFFFFF']
  },
  secondary: {
    name: 'Secondary Colors',
    colors: ['#FF8000', '#8000FF', '#0080FF', '#80FF00', '#FF0080', '#00FF80', '#808080', '#400040']
  },
  warm: {
    name: 'Warm Colors',
    colors: ['#FF6B35', '#F7931E', '#FFD23F', '#EE4B2B', '#DC143C', '#B22222', '#A0522D', '#CD853F']
  },
  cool: {
    name: 'Cool Colors',
    colors: ['#00CED1', '#20B2AA', '#008B8B', '#4682B4', '#6495ED', '#7B68EE', '#9370DB', '#8A2BE2']
  }
};

// Current active palette
let activePalette = 'pastel'; // Default to pastel palette instead of 'none'
let selectedPaletteColor = null;

let selectedId = null;
let editingTextId = null;

let drawing = false;
let currentStroke = null;

let dragging = false;
let rotating = false;
let resizing = false;

let dragStart = null;
let dragOffset = null;

let lastClickTime = 0;
let lastClickTarget = null;
const DOUBLE_CLICK_TIME = 300;

// Enhanced scaling/resizing state
let activeHandle = null;
let initialBounds = null;
let initialMouse = null;
let aspectRatio = null;
let shiftPressed = false;

const originalPositions = new Map();
let currentHandles = [];

// Add these variables at the top (after other state variables)
let multiMoving = false;
let multiMoveStart = null;
let multiMoveOriginals = null;
let multiRotating = false;
let multiRotateStart = null;
let multiRotateOriginals = null;

let ignoreNextCtxMenuClose = false;

// Track hovered multi-selection handle for visual feedback
let hoveredMultiHandle = null;


/* ======= Page Management ======= */
function createNewPage() {
  return {
    id: nextPageId++,
    objects: [],
    undoStack: [],
    redoStack: []
  };
}

function saveCurrentPageState() {
  if (pages.length > 0 && currentPageIndex < pages.length) {
    pages[currentPageIndex].objects = structuredCloneSafe(objects);
    pages[currentPageIndex].undoStack = structuredCloneSafe(undoStack);
    pages[currentPageIndex].redoStack = structuredCloneSafe(redoStack);
  }
}

function loadPageState(pageIndex) {
  console.log('=== LOADING PAGE STATE ===');
  console.log('Loading page index:', pageIndex);
  console.log('Total pages:', pages.length);
  
  if (pageIndex < 0 || pageIndex >= pages.length) {
    console.log('ERROR: Invalid page index!');
    return;
  }
  
  const page = pages[pageIndex];
  console.log('Loading page data:', page);
  console.log('Page objects:', page.objects);
  console.log('Page objects count:', page.objects?.length || 0);
  
  objects = structuredCloneSafe(page.objects);
  undoStack = structuredCloneSafe(page.undoStack);
  redoStack = structuredCloneSafe(page.redoStack);
  
  console.log('After cloning - objects:', objects);
  console.log('After cloning - objects count:', objects.length);
  
  selectedId = null;
  resetUIControls();
  console.log('Calling redraw...');
  redraw();
  console.log('redraw() completed');
}

function switchToPage(pageIndex) {
  if (pageIndex === currentPageIndex) return;
  if (pageIndex < 0 || pageIndex >= pages.length) return;
  
  saveCurrentPageState();
  currentPageIndex = pageIndex;
  loadPageState(pageIndex);
  updatePageControls();
}

function addNewPage() {
  saveCurrentPageState();
  const newPage = createNewPage();
  pages.push(newPage);
  currentPageIndex = pages.length - 1;
  loadPageState(currentPageIndex);
  updatePageControls();
}

function insertPageAtCurrentLocation() {
  saveCurrentPageState();
  const newPage = createNewPage();
  // Insert after current page
  pages.splice(currentPageIndex + 1, 0, newPage);
  currentPageIndex = currentPageIndex + 1;
  loadPageState(currentPageIndex);
  updatePageControls();
}

function insertPageBeforeCurrent() {
  saveCurrentPageState();
  const newPage = createNewPage();
  pages.splice(currentPageIndex, 0, newPage);
  loadPageState(currentPageIndex);
  updatePageControls();
}

function deleteCurrentPage() {
  if (pages.length <= 1) {
    alert("Cannot delete the last page.");
    return;
  }
  
  if (!confirm(`Delete page ${currentPageIndex + 1}?`)) return;
  
  pages.splice(currentPageIndex, 1);
  
  if (currentPageIndex >= pages.length) {
    currentPageIndex = pages.length - 1;
  }
  
  loadPageState(currentPageIndex);
  updatePageControls();
}

function updatePageControls() {
  const pageInfo = document.getElementById('page-info');
  const prevBtn = document.getElementById('prev-page');
  const nextBtn = document.getElementById('next-page');
  const deleteBtn = document.getElementById('delete-page');
  
  pageInfo.textContent = `${currentPageIndex + 1} / ${pages.length}`;
  
  prevBtn.disabled = currentPageIndex <= 0;
  nextBtn.disabled = currentPageIndex >= pages.length - 1;
  deleteBtn.disabled = pages.length <= 1;
}

/* ======= Bootstrap from server JSON (safe) ======= */
/* ======= Fabric.js Migration Helper ======= */
function parseFabricPath(fabricPath) {
  // Convert Fabric.js path array to current format points
  const points = [];
  
  if (!fabricPath || !Array.isArray(fabricPath)) return points;
  
  try {
    for (let i = 0; i < fabricPath.length; i++) {
      const segment = fabricPath[i];
      if (Array.isArray(segment) && segment.length >= 3) {
        const command = segment[0];
        if (command === 'M' || command === 'L') {
          // Move to or Line to
          points.push({
            x: segment[1] || 0,
            y: segment[2] || 0
          });
        } else if (command === 'Q' && segment.length >= 5) {
          // Quadratic curve - add the end point
          points.push({
            x: segment[3] || 0,
            y: segment[4] || 0
          });
        } else if (command === 'C' && segment.length >= 7) {
          // Cubic curve - add the end point
          points.push({
            x: segment[5] || 0,
            y: segment[6] || 0
          });
        }
      }
    }
  } catch (e) {
    console.warn('Error parsing Fabric.js path:', e);
  }
  
  return points;
}

/* ======= Bootstrap and Data Loading ======= */
(function bootstrap(){
  try{
    const raw = document.getElementById('initial-board-data')?.textContent || 'null';
    console.log('=== LOADING BOARD DATA ===');
    console.log('Raw board data:', raw);
    console.log('Raw data length:', raw.length);
    
    const parsed = JSON.parse(raw);
    console.log('Parsed board data:', parsed);
    
    if(parsed){
      if(parsed.pages && Array.isArray(parsed.pages) && parsed.pages.length > 0) {
        // Multi-page format (current format)
        console.log('Loading multi-page format, pages:', parsed.pages);
        console.log('Number of pages:', parsed.pages.length);
        
        pages = parsed.pages;
        currentPageIndex = Math.max(0, Math.min(parsed.currentPageIndex || 0, pages.length - 1));
        nextPageId = parsed.nextPageId || (pages.reduce((m,p)=>Math.max(m,p.id||0),0)+1) || 1;
        nextObjectId = parsed.nextObjectId || 1;
        
        console.log('Set currentPageIndex to:', currentPageIndex);
        console.log('Set nextPageId to:', nextPageId);
        console.log('Set nextObjectId to:', nextObjectId);
        
        if(pages.length > 0) {
          console.log('Loading page state for index:', currentPageIndex);
          console.log('Page data:', pages[currentPageIndex]);
          console.log('Page objects count:', pages[currentPageIndex]?.objects?.length || 0);
          
          loadPageState(currentPageIndex);
          
          console.log('After loadPageState - objects array:', objects);
          console.log('After loadPageState - objects count:', objects.length);
        } else {
          console.log('Pages array is empty, creating new page');
          pages = [createNewPage()];
          currentPageIndex = 0;
          loadPageState(0);
        }
      } else if(parsed.objects) {
        // Legacy format - could be either old app format or Fabric.js format
        console.log('Loading legacy format, objects count:', parsed.objects.length);
        let convertedObjects = [];
        
        // Check if it's Fabric.js format (has version property and objects array)
        if(parsed.version && typeof parsed.version === 'string' && parsed.version.includes('.')) {
          console.log('Detected Fabric.js format version:', parsed.version, 'converting to current format...');
          // Convert Fabric.js objects to current format
          convertedObjects = (parsed.objects || []).map((obj, index) => {
            console.log('Converting object:', index, obj.type, obj);
            // Convert Fabric.js object to current whiteboard format
            if(obj.type === 'path') {
              // Convert Fabric.js path to stroke
              const converted = {
                id: index + 1,
                type: 'stroke',
                layer: 0,
                props: {
                  color: obj.stroke || '#000000',
                  size: obj.strokeWidth || 4,
                  path: obj.path ? parseFabricPath(obj.path) : []
                }
              };
              console.log('Converted path to stroke:', converted);
              return converted;
            } else if(obj.type === 'i-text' || obj.type === 'textbox') {
              // Convert Fabric.js text to current text format
              const converted = {
                id: index + 1,
                type: 'text',
                layer: 0,
                props: {
                  text: obj.text || '',
                  x: obj.left || 0,
                  y: obj.top || 0,
                  fontSize: obj.fontSize || 24,
                  color: obj.fill || '#000000'
                }
              };
              console.log('Converted text:', converted);
              return converted;
            } else {
              // Generic object conversion
              console.log('Unknown object type:', obj.type);
              return {
                id: index + 1,
                type: 'unknown',
                layer: 0,
                props: obj
              };
            }
          });
        } else {
          // Old app legacy format
          console.log('Using old app legacy format');
          convertedObjects = parsed.objects || [];
        }
        
        pages = [{
          id: nextPageId++,
          objects: convertedObjects,
          undoStack: parsed.undoStack || [],
          redoStack: parsed.redoStack || []
        }];
        currentPageIndex = 0;
        nextObjectId = (convertedObjects.reduce((m,o)=>Math.max(m,o.id||0),0)+1) || 1;
        console.log('Created page with objects:', convertedObjects.length);
        loadPageState(0);
      }
    } else {
      // No data - create first page
      console.log('No data, creating new page');
      pages = [createNewPage()];
      currentPageIndex = 0;
      console.log('Created first page, pages:', pages);
      loadPageState(0);
      console.log('After loadPageState, objects:', objects);
    }
  }catch(e){ 
    console.error('Error loading board data:', e);
    pages = [createNewPage()];
    currentPageIndex = 0;
    loadPageState(0);
  }
  updatePageControls();
})();

/* ======= Command System ======= */
function redraw(){
  currentHandles = render() || [];
}

function executeCommand(cmd){
  applyCommand(cmd);
  undoStack.push(cmd);
  redoStack = [];
  redraw();
}

function commitAppliedChange(cmd){
  undoStack.push(cmd);
  redoStack = [];
  redraw();
}

function undo(){
  const cmd = undoStack.pop();
  if(!cmd) return;
  applyInverse(cmd);
  redoStack.push(cmd);
  redraw();
}

function redo(){
  const cmd = redoStack.pop();
  if(!cmd) return;
  applyCommand(cmd);
  undoStack.push(cmd);
  redraw();
}

function applyCommand(cmd){
  switch(cmd.type){
    case "add":
      objects.push(structuredCloneSafe(cmd.object));
      break;
    case "delete":
      objects = objects.filter(o => o.id !== cmd.object.id);
      break;
    case "updateProps": {
      const o = findById(cmd.id); if(o) Object.assign(o.props, cmd.next);
      break;
    }
    case "updateRoot": {
      const o = findById(cmd.id); if(o) Object.assign(o, cmd.next);
      break;
    }
    case "batch":
      cmd.commands.forEach(applyCommand);
      break;
  }
}

function applyInverse(cmd){
  switch(cmd.type){
    case "add":
      objects = objects.filter(o => o.id !== cmd.object.id);
      break;
    case "delete":
      objects.push(structuredCloneSafe(cmd.object));
      break;
    case "updateProps": {
      const o = findById(cmd.id); if(o) Object.assign(o.props, cmd.prev);
      break;
    }
    case "updateRoot": {
      const o = findById(cmd.id); if(o) Object.assign(o, cmd.prev);
      break;
    }
    case "batch":
      for(let i = cmd.commands.length - 1; i >= 0; i--){
        applyInverse(cmd.commands[i]);
      }
      break;
  }
}

function structuredCloneSafe(v){
  if (window.structuredClone) return structuredClone(v);
  return JSON.parse(JSON.stringify(v));
}

/* ======= Utilities ======= */
function addObject(obj){ executeCommand({type:"add", object: obj}); }
function removeByIdCmd(o){ executeCommand({type:"delete", object: structuredCloneSafe(o)}); }

function findById(id){ return objects.find(o=>o.id===id); }

function toCanvasXY(e){
  const r=canvas.getBoundingClientRect();
  const x=(e.clientX-r.left)*(canvas.width/r.width);
  const y=(e.clientY-r.top)*(canvas.height/r.height);
  return {x,y};
}
function clearCanvas(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

function manageImageCache(){
  if(imageCache.size > MAX_CACHED_IMAGES){
    const entries = Array.from(imageCache.entries());
    const toRemove = entries.slice(0, imageCache.size - MAX_CACHED_IMAGES);
    toRemove.forEach(([key]) => imageCache.delete(key));
  }
}

function updateCursor(){
  if(currentTool === 'select'){ canvas.style.cursor = 'default'; }
  else if(currentTool === 'text'){ canvas.style.cursor = 'text'; }
  else { canvas.style.cursor = 'crosshair'; }
}

function updateStatus(){
  // If rectangle selection is active and multiSelectedIds is not empty
  if (currentTool === 'rect-select' && multiSelectedIds.size > 0) {
    if (multiSelectedIds.size === 1) {
      // Show details for the single selected object
      const id = Array.from(multiSelectedIds)[0];
      const o = findById(id);
      if (o) {
        const parts=[`id:${o.id}`,`type:${o.type}`,`layer:${o.layer}`];
        const objText = o.props?.text || o.text;
        if(o.type==='text' && objText) parts.push(`text:"${objText.slice(0,40)}"`);
        statusbar.textContent = `Page ${currentPageIndex + 1}/${pages.length} - ` + parts.join('  ‚Ä¢  ') + (shiftPressed ? ' [SHIFT: Constrain aspect ratio]' : '');
        syncUIWithSelectedObject(o);
        return;
      }
    } else {
      // Show summary for multi-selection
      const selectedObjects = Array.from(multiSelectedIds).map(id => findById(id)).filter(Boolean);
      const typeCounts = selectedObjects.reduce((acc, obj) => {
        acc[obj.type] = (acc[obj.type] || 0) + 1;
        return acc;
      }, {});
      const typeSummary = Object.entries(typeCounts)
        .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
        .join(', ');
      statusbar.textContent = `Page ${currentPageIndex + 1}/${pages.length} - ${multiSelectedIds.size} objects selected (${typeSummary})`;
      resetUIControls();
      return;
    }
  }

  // Fallback: single selection (select tool)
  if(selectedId==null){ 
    statusbar.textContent = `Page ${currentPageIndex + 1}/${pages.length} - No selection`; 
    return; 
  }
  const o=findById(selectedId); 
  if(!o){ 
    statusbar.textContent=`Page ${currentPageIndex + 1}/${pages.length} - No selection`; 
    return; 
  }
  
  const parts=[`id:${o.id}`,`type:${o.type}`,`layer:${o.layer}`];
  const objText = o.props?.text || o.text;
  if(o.type==='text' && objText) parts.push(`text:"${objText.slice(0,40)}"`);
  statusbar.textContent = `Page ${currentPageIndex + 1}/${pages.length} - ` + parts.join('  ‚Ä¢  ') + (shiftPressed ? ' [SHIFT: Constrain aspect ratio]' : '');
  
  syncUIWithSelectedObject(o);
}

function syncUIWithSelectedObject(o) {
  const colorPicker = document.getElementById('color-picker');
  const sizeRange = document.getElementById('size-range');
  const textSize = document.getElementById('text-size');
  const transparencyControl = document.getElementById('transparency-control');
  const transparencyRange = document.getElementById('transparency-range');
  
  if(o.type === 'stroke') {
    const objColor = o.props?.color || o.color;
    const objSize = o.props?.size || o.size;
    const strokeType = o.props?.strokeType || o.strokeType || 'pen'; // Default to pen for legacy strokes
    
    if(objColor) {
      colorPicker.value = objColor;
      color = objColor;
      // Update tool color memory based on stroke type
      if (toolColors[strokeType]) {
        toolColors[strokeType] = objColor;
      }
    }
    if(objSize) {
      sizeRange.value = objSize;
      size = objSize;
      // Update tool size memory based on stroke type
      if (toolSizes[strokeType]) {
        toolSizes[strokeType] = objSize;
      }
    }
    
    // Show transparency control for highlighter and marker strokes
    if(strokeType === 'highlighter' || strokeType === 'marker') {
      transparencyControl.classList.remove('hidden');
      transparencyControl.classList.add('flex');
      const objTransparency = o.props?.transparency ?? o.transparency;
      if(objTransparency !== undefined) {
        currentTransparency = objTransparency;
        transparencyRange.value = currentTransparency;
        document.getElementById('transparency-value').textContent = Math.round(currentTransparency * 100) + '%';
      }
    } else {
      transparencyControl.classList.add('hidden');
      transparencyControl.classList.remove('flex');
    }
    
    colorPicker.disabled = false;
    sizeRange.disabled = false;
    textSize.disabled = true;
  } else if(o.type === 'text') {
    const objColor = o.props?.color || o.color;
    const objFontSize = o.props?.fontSize || o.fontSize;
    
    if(objColor) {
      colorPicker.value = objColor;
      color = objColor;
      // Update text tool color memory when selecting a text object
      toolColors.text = objColor;
    }
    if(objFontSize) {
      textSize.value = objFontSize;
    }
    colorPicker.disabled = false;
    sizeRange.disabled = true;
    textSize.disabled = false;
  } else if(o.type === 'image') {
    colorPicker.disabled = true;
    sizeRange.disabled = true;
    textSize.disabled = true;
  } else {
    colorPicker.disabled = false;
    sizeRange.disabled = false;
    textSize.disabled = false;
  }
}

function resetUIControls() {
  const colorPicker = document.getElementById('color-picker');
  const sizeRange = document.getElementById('size-range');
  const textSize = document.getElementById('text-size');
  const transparencyControl = document.getElementById('transparency-control');
  
  colorPicker.disabled = false;
  sizeRange.disabled = false;
  textSize.disabled = false;
  
  // Hide transparency control unless highlighter tool is active
  if(currentTool !== 'highlighter') {
    transparencyControl.classList.add('hidden');
    transparencyControl.classList.remove('flex');
  }
}

/* ======= Enhanced Drawing with rotation support ======= */
function drawObject(o){
  if(o.type==='stroke'){
    ctx.save();
    ctx.lineJoin='round'; ctx.lineCap='round';
    const objColor = o.props?.color || o.color;
    const objSize = o.props?.size || o.size;
    const strokeType = o.props?.strokeType || o.strokeType;
    const objTransparency = o.props?.transparency ?? o.transparency;
    
    ctx.strokeStyle = objColor; 
    ctx.lineWidth = objSize;
    
    // Apply transparency for marker and highlighter strokes
    if(strokeType === 'marker') {
      ctx.globalAlpha = objTransparency || toolTransparencies.marker || 0.6;
    } else if(strokeType === 'highlighter') {
      ctx.globalAlpha = objTransparency || toolTransparencies.highlighter || 0.4;
    }
    
    ctx.beginPath();
    const objPath = o.props?.path || o.path || [];
    
    // Use the shapes module drawing function for all shape types
    if (isShapeTool(strokeType) && objPath.length >= 2) {
      drawShapeStroke(ctx, o);
    } else {
      // Draw normal stroke path (pen, marker, highlighter, line)
      if(objPath.length){ 
        ctx.moveTo(objPath[0].x,objPath[0].y); 
        for(let i=1;i<objPath.length;i++) ctx.lineTo(objPath[i].x,objPath[i].y);
      }
    }
    ctx.stroke();
    ctx.restore();
    
  } else if(o.type==='image'){
    ctx.save();
    const objSrc = o.props?.src || o.src;
    const objX = o.props?.x || o.x || 0;
    const objY = o.props?.y || o.y || 0;
    const objW = o.props?.w || o.w || 0;
    const objH = o.props?.h || o.h || 0;
    const objRotation = o.props?.rotation || o.rotation;
    
    let img=imageCache.get(objSrc);
    if(!img){ img=new Image(); img.src=objSrc; img.onload=()=>redraw(); imageCache.set(objSrc,img); manageImageCache(); }
    
    if(img.complete && img.width > 0) { 
      try{
        if(objRotation) {
          const centerX = objX + objW/2;
          const centerY = objY + objH/2;
          ctx.translate(centerX, centerY);
          ctx.rotate(objRotation);
          ctx.drawImage(img, -objW/2, -objH/2, objW, objH);
        } else {
          ctx.drawImage(img, objX, objY, objW, objH);
        }
      }catch(e){}
    }
    ctx.restore();
    
  } else if(o.type==='text'){
    ctx.save();
    const objFontSize = o.props?.fontSize || o.fontSize || 24;
    const objColor = o.props?.color || o.color || '#000';
    const objText = o.props?.text || o.text || '';
    const objX = o.props?.x || o.x || 0;
    const objY = o.props?.y || o.y || 0;
    const objRotation = o.props?.rotation || o.rotation;
    const objMaxWordsPerLine = o.props?.maxWordsPerLine || o.maxWordsPerLine || userPrefs.maxWordsPerLine || 10;
    
    ctx.font = objFontSize + 'px sans-serif';
    ctx.fillStyle = objColor;
    ctx.textBaseline = 'alphabetic';

    // Use the text object's own word wrapping property, or fall back to current settings
    const wrappedText = autoWrapTextByWords(objText, objMaxWordsPerLine);
    const lines = wrappedText.split('\n');
    const lineHeight = objFontSize * 1.2;

    if(objRotation){
      ctx.translate(objX, objY);
      ctx.rotate(objRotation);
      lines.forEach((line, i) => ctx.fillText(line, 0, i * lineHeight));
    } else {
      lines.forEach((line, i) => ctx.fillText(line, objX, objY + i * lineHeight));
    }
    ctx.restore();
  }
}

function drawArrow(startX, startY, endX, endY, size) {
  // Draw the line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();
  
  // Calculate arrowhead
  const angle = Math.atan2(endY - startY, endX - startX);
  const arrowLength = size * 3; // Arrowhead length based on stroke size
  const arrowAngle = Math.PI / 6; // 30 degrees
  
  // Draw arrowhead
  ctx.beginPath();
  ctx.moveTo(endX, endY);
  ctx.lineTo(
    endX - arrowLength * Math.cos(angle - arrowAngle),
    endY - arrowLength * Math.sin(angle - arrowAngle)
  );
  ctx.moveTo(endX, endY);
  ctx.lineTo(
    endX - arrowLength * Math.cos(angle + arrowAngle),
    endY - arrowLength * Math.sin(angle + arrowAngle)
  );
  ctx.stroke();
}

function drawRoundedRectangle(startX, startY, endX, endY, size) {
  const x = Math.min(startX, endX);
  const y = Math.min(startY, endY);
  const w = Math.abs(endX - startX);
  const h = Math.abs(endY - startY);
  
  // Corner radius based on stroke size, with a reasonable maximum
  const radius = Math.min(size * 2, Math.min(w, h) / 4);
  
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + w - radius, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
  ctx.lineTo(x + w, y + h - radius);
  ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
  ctx.lineTo(x + radius, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}

function drawDecision(startX, startY, endX, endY, size) {
  const x = Math.min(startX, endX);
  const y = Math.min(startY, endY);
  const w = Math.abs(endX - startX);
  const h = Math.abs(endY - startY);
  
  // Calculate diamond points
  const centerX = x + w / 2;
  const centerY = y + h / 2;
  
  ctx.beginPath();
  ctx.moveTo(centerX, y); // Top point
  ctx.lineTo(x + w, centerY); // Right point
  ctx.lineTo(centerX, y + h); // Bottom point
  ctx.lineTo(x, centerY); // Left point
  ctx.closePath();
}

function drawInputOutput(startX, startY, endX, endY, size) {
  const x = Math.min(startX, endX);
  const y = Math.min(startY, endY);
  const w = Math.abs(endX - startX);
  const h = Math.abs(endY - startY);
  
  // Parallelogram with 20% skew
  const skew = w * 0.2;
  
  ctx.beginPath();
  ctx.moveTo(x + skew, y);
  ctx.lineTo(x + w, y);
  ctx.lineTo(x + w - skew, y + h);
  ctx.lineTo(x, y + h);
  ctx.closePath();
}

function drawConnector(startX, startY, endX, endY, size) {
  const x = Math.min(startX, endX);
  const y = Math.min(startY, endY);
  const w = Math.abs(endX - startX);
  const h = Math.abs(endY - startY);
  
  // Draw circle with diameter equal to the smaller dimension
  const diameter = Math.min(w, h);
  const centerX = x + w / 2;
  const centerY = y + h / 2;
  const radius = diameter / 2;
  
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
  ctx.closePath();
}

function drawCurrentStroke(){
  if(!currentStroke || !currentStroke.length) return;
  ctx.save();
  ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.strokeStyle = color; ctx.lineWidth = size;
  
  // Apply transparency for marker and highlighter while drawing
  if(currentTool === 'marker') {
    ctx.globalAlpha = currentTransparency;
  } else if(currentTool === 'highlighter') {
    ctx.globalAlpha = currentTransparency;
  }
  
  ctx.beginPath();
  // Use shapes module for all shape tools
  if(isShapeTool(currentTool) && currentStroke.length >= 2) {
    const tempStroke = {
      type: 'stroke',
      props: {
        path: currentStroke,
        strokeType: currentTool,
        size: size
      }
    };
    drawShapeStroke(ctx, tempStroke);
  } else {
    // Draw normal stroke path
    ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
    for(let i=1; i<currentStroke.length; i++) ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
  }
  ctx.stroke();
  ctx.restore();
}

/* ======= Enhanced Selection handles with better rotation ======= */
function drawSelectionHandles(o){
  const b = getBounds(o);
  const handleSize = 8;
  const rotateDistance = 30;
  
  const handles = [
    {type: 'resize-nw', x: b.x - handleSize/2, y: b.y - handleSize/2},
    {type: 'resize-ne', x: b.x + b.w - handleSize/2, y: b.y - handleSize/2},
    {type: 'resize-sw', x: b.x - handleSize/2, y: b.y + b.h - handleSize/2},
    {type: 'resize-se', x: b.x + b.w - handleSize/2, y: b.y + b.h - handleSize/2},
    {type: 'resize-n', x: b.x + b.w/2 - handleSize/2, y: b.y - handleSize/2},
    {type: 'resize-s', x: b.x + b.w/2 - handleSize/2, y: b.y + b.h - handleSize/2},
    {type: 'resize-e', x: b.x + b.w - handleSize/2, y: b.y + b.h/2 - handleSize/2},
    {type: 'resize-w', x: b.x - handleSize/2, y: b.y + b.h/2 - handleSize/2},
    {type: 'rotate', x: b.x + b.w/2 - handleSize/2, y: b.y - rotateDistance - handleSize/2}
  ];

  ctx.save();
  ctx.fillStyle = '#0078d4';
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  
  for(let i = 0; i < 8; i++){
    const h = handles[i];
    ctx.fillRect(h.x, h.y, handleSize, handleSize);
    ctx.strokeRect(h.x, h.y, handleSize, handleSize);
  }
  
  const rotHandle = handles[8];
  ctx.beginPath();
  ctx.arc(rotHandle.x + handleSize/2, rotHandle.y + handleSize/2, handleSize/2, 0, Math.PI * 2);
  ctx.fill(); ctx.stroke();
  
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(rotHandle.x + handleSize/2, rotHandle.y + handleSize/2, 3, -Math.PI/3, Math.PI/3);
  ctx.stroke();

  ctx.strokeStyle = '#0078d4';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(b.x + b.w/2, b.y);
  ctx.lineTo(rotHandle.x + handleSize/2, rotHandle.y + handleSize/2);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  return handles;
}

function getHandleAt(handles, pt){
  const handleSize = 8;
  return handles.find(h => pt.x >= h.x && pt.x <= h.x + handleSize &&
                           pt.y >= h.y && pt.y <= h.y + handleSize);
}

function getMultiHandleAt(handles, pt){
  return handles.find(h => pt.x >= h.x && pt.x <= h.x + h.w &&
                           pt.y >= h.y && pt.y <= h.y + h.h);
}

function getCursorForHandle(handleType) {
  switch(handleType) {
    case 'resize-nw': case 'resize-se': return 'nw-resize';
    case 'resize-ne': case 'resize-sw': return 'ne-resize';
    case 'resize-n': case 'resize-s': return 'n-resize';
    case 'resize-e': case 'resize-w': return 'e-resize';
    case 'rotate': return 'grab';
    default: return 'default';
  }
}

/* ======= Enhanced rotation system for all objects ======= */
function getObjectCenter(o) {
  const b = getBounds(o);
  return { x: b.x + b.w/2, y: b.y + b.h/2 };
}

function rotatePoint(px, py, cx, cy, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const dx = px - cx;
  const dy = py - cy;
  return {
    x: cx + dx * cos - dy * sin,
    y: cy + dx * sin + dy * cos
  };
}

function performRotation(o, currentAngle, initialAngle) {
  const center = originalPositions.get(o.id)?.center;
  if(!center) return;
  
  const deltaAngle = currentAngle - initialAngle;
  
  if(o.type === 'image' || o.type === 'text') {
    o.props.rotation = (o.props.rotation || 0) + deltaAngle;
  } else if(o.type === 'stroke') {
    const originalPath = originalPositions.get(o.id)?.path || [];
    o.props.path = originalPath.map(pt => 
      rotatePoint(pt.x, pt.y, center.x, center.y, deltaAngle)
    );
  }
}

/* ======= Bounds and hit-testing ======= */
function getBounds(o){
  if(o.type==='image') return {x:o.props.x,y:o.props.y,w:o.props.w,h:o.props.h};

  if(o.type==='text'){
    const fs = o.props.fontSize || 24;
    ctx.save();
    ctx.font = fs + 'px sans-serif';
    // Use the text object's own word wrapping property for bounds calculation
    const maxWordsPerLine = o.props.maxWordsPerLine || userPrefs.maxWordsPerLine || 10;
    const wrappedText = autoWrapTextByWords(o.props.text || '', maxWordsPerLine);
    const lines = wrappedText.split('\n');
    let maxWidth = 0;
    lines.forEach(line => {
      const m = ctx.measureText(line);
      maxWidth = Math.max(maxWidth, m.width);
    });
    const lineHeight = fs * 1.2;
    const totalHeight = lines.length * lineHeight;
    ctx.restore();
    return { x:o.props.x, y:o.props.y - fs, w:maxWidth, h:totalHeight };
  }

  const pts=o.props.path||[]; if(!pts.length) return {x:0,y:0,w:0,h:0};
  const xs=pts.map(p=>p.x), ys=pts.map(p=>p.y);
  const minx=Math.min(...xs)-o.props.size, maxx=Math.max(...xs)+o.props.size;
  const miny=Math.min(...ys)-o.props.size, maxy=Math.max(...ys)+o.props.size;
  return {x:minx,y:miny,w:maxx-minx,h:maxy-miny};
}

function render(){
  console.log('=== RENDER CALLED ===');
  console.log('Objects to render:', objects);
  console.log('Objects count:', objects.length);
  
  clearCanvas();
  const sorted=[...objects].sort((a,b)=> (a.layer-b.layer) || (a.id-b.id));
  console.log('Sorted objects:', sorted);
  
  for(const o of sorted) {
    console.log('Drawing object:', o.id, o.type);
    drawObject(o);
  }

  if(drawing && currentStroke) drawCurrentStroke();

  let handles = [];
  if(selectedId!=null){
    const s=findById(selectedId);
    if(s){
      const b=getBounds(s);
      ctx.save();
      ctx.strokeStyle='rgba(0,120,215,.9)';
      ctx.setLineDash([6,4]);
      ctx.lineWidth=2;
      ctx.strokeRect(b.x-4,b.y-4,b.w+8,b.h+8);
      ctx.restore();

      if(currentTool === 'select'){
        handles = drawSelectionHandles(s);
      }
    }
  }

  // --- MULTI-SELECTION UI WITH MODERN ICONS ---
  if(multiSelectedIds.size > 0){
    // Calculate union bounding box
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for(const id of multiSelectedIds){
      const o = findById(id);
      if(o){
        const b = getBounds(o);
        minX = Math.min(minX, b.x-4);
        minY = Math.min(minY, b.y-4);
        maxX = Math.max(maxX, b.x+b.w+8);
        maxY = Math.max(maxY, b.y+b.h+8);
      }
    }
    ctx.save();
    
    // Modern gradient background with subtle teal accent
    if(isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)){
      const gradient = ctx.createLinearGradient(minX, minY, maxX, maxY);
      gradient.addColorStop(0, 'rgba(20, 184, 166, 0.08)'); // Teal from theme
      gradient.addColorStop(1, 'rgba(20, 184, 166, 0.15)');
      ctx.fillStyle = gradient;
      ctx.fillRect(minX, minY, maxX-minX, maxY-minY);

      // Helper function to draw modern icon button with gradient and shadow
      function drawModernIconButton(x, y, iconDrawFn, color = '#14b8a6', isHovered = false) {
        ctx.save();
        
        // Scale and offset for hover effect
        const scale = isHovered ? 1.15 : 1.0;
        const radius = 13 * scale;
        
        // Shadow for depth (enhanced on hover)
        ctx.shadowColor = isHovered ? 'rgba(0, 0, 0, 0.35)' : 'rgba(0, 0, 0, 0.2)';
        ctx.shadowBlur = isHovered ? 6 : 4;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = isHovered ? 3 : 2;
        
        // Gradient background
        const gradient = ctx.createRadialGradient(x + 12, y + 12, 0, x + 12, y + 12, radius + 1);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, darkenColor(color, 0.2));
        ctx.fillStyle = gradient;
        
        // Draw circle
        ctx.beginPath();
        ctx.arc(x + 12, y + 12, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // White border (thicker on hover)
        ctx.shadowColor = 'transparent';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = isHovered ? 3 : 2.5;
        ctx.stroke();
        
        // Draw icon
        iconDrawFn(x + 12, y + 12);
        
        ctx.restore();
      }

      // Helper to darken colors
      function darkenColor(color, factor) {
        const hex = color.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        return `rgb(${Math.floor(r * (1 - factor))}, ${Math.floor(g * (1 - factor))}, ${Math.floor(b * (1 - factor))})`;
      }

      // Draw move handle (center top) - 4-way arrows icon
      const moveX = (minX + maxX) / 2 - 12;
      const moveY = minY - 32;
      const isMoveHovered = hoveredMultiHandle === 'multi-move';
      drawModernIconButton(moveX, moveY, (cx, cy) => {
        ctx.strokeStyle = '#fff';
        ctx.fillStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Draw 4-way arrows (up, down, left, right)
        const arrowSize = 5;
        
        // Up arrow
        ctx.beginPath();
        ctx.moveTo(cx, cy - 6);
        ctx.lineTo(cx - 3, cy - 2);
        ctx.moveTo(cx, cy - 6);
        ctx.lineTo(cx + 3, cy - 2);
        ctx.stroke();
        
        // Down arrow
        ctx.beginPath();
        ctx.moveTo(cx, cy + 6);
        ctx.lineTo(cx - 3, cy + 2);
        ctx.moveTo(cx, cy + 6);
        ctx.lineTo(cx + 3, cy + 2);
        ctx.stroke();
        
        // Left arrow
        ctx.beginPath();
        ctx.moveTo(cx - 6, cy);
        ctx.lineTo(cx - 2, cy - 3);
        ctx.moveTo(cx - 6, cy);
        ctx.lineTo(cx - 2, cy + 3);
        ctx.stroke();
        
        // Right arrow
        ctx.beginPath();
        ctx.moveTo(cx + 6, cy);
        ctx.lineTo(cx + 2, cy - 3);
        ctx.moveTo(cx + 6, cy);
        ctx.lineTo(cx + 2, cy + 3);
        ctx.stroke();
      }, '#14b8a6', isMoveHovered);

      // Draw rotate handle (center right) - circular arrow icon
      const rotX = maxX + 28;
      const rotY = (minY + maxY) / 2 - 12;
      const isRotateHovered = hoveredMultiHandle === 'multi-rotate';
      drawModernIconButton(rotX - 12, rotY, (cx, cy) => {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        
        // Draw circular arrow
        ctx.beginPath();
        ctx.arc(cx, cy, 5, -0.3 * Math.PI, 1.5 * Math.PI);
        ctx.stroke();
        
        // Arrowhead
        ctx.beginPath();
        ctx.moveTo(cx - 1, cy - 5);
        ctx.lineTo(cx - 4, cy - 5);
        ctx.lineTo(cx - 2.5, cy - 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }, '#0d9488', isRotateHovered);

      // Draw menu handle (center left) - modern grid icon
      const menuX = minX - 40;
      const menuY = (minY + maxY) / 2 - 12;
      const isMenuHovered = hoveredMultiHandle === 'multi-menu';
      drawModernIconButton(menuX, menuY, (cx, cy) => {
        ctx.fillStyle = '#fff';
        const dotSize = 2;
        const spacing = 4.5;
        
        // Draw 3x3 grid of dots
        for(let row = -1; row <= 1; row++) {
          for(let col = -1; col <= 1; col++) {
            ctx.beginPath();
            ctx.arc(cx + col * spacing, cy + row * spacing, dotSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }, '#14b8a6', isMenuHovered);

      // Save handles for hit-testing
      handles = [
        {type: "multi-move", x: moveX, y: moveY, w: 24, h: 24},
        {type: "multi-rotate", x: rotX - 12, y: rotY, w: 24, h: 24},
        {type: "multi-menu", x: menuX, y: menuY, w: 24, h: 24}
      ];
    }
    ctx.restore();
  }

  // Draw highlight boxes for all in highlightIds (for rect-select preview)
  let highlightIds = new Set(multiSelectedIds);
  if(currentTool === 'rect-select' && rectSelecting && rectSelectStart && rectSelectEnd){
    // Compute which objects are in the current rectangle
    const selRect = getRectFromPoints(rectSelectStart, rectSelectEnd);
    highlightIds = new Set();
    for(const o of objects){
      if(isObjectFullyInRect(o, selRect)){
        highlightIds.add(o.id);
      }
    }
  }

  if(highlightIds.size > 0){
    ctx.save();
    ctx.strokeStyle = 'rgba(0,120,215,0.7)';
    ctx.setLineDash([2,2]);
    ctx.lineWidth = 2;
    for(const id of highlightIds){
      const o = findById(id);
      if(o){
        const b = getBounds(o);
        ctx.strokeRect(b.x-4, b.y-4, b.w+8, b.h+8);
      }
    }
    ctx.restore();
  }

  // Draw rectangle selection (always on top)
  if(currentTool === 'rect-select' && rectSelecting && rectSelectStart && rectSelectEnd){
    const r = getRectFromPoints(rectSelectStart, rectSelectEnd);
    ctx.save();
    ctx.strokeStyle = '#0078d4';
    ctx.setLineDash([4,4]);
    ctx.lineWidth = 2;
    ctx.strokeRect(r.x, r.y, r.w, r.h);
    ctx.restore();
  }

  updateStatus();
  return handles;
}

// Utility: get rectangle from two points
function getRectFromPoints(a, b){
  const x = Math.min(a.x, b.x);
  const y = Math.min(a.y, b.y);
  const w = Math.abs(a.x - b.x);
  const h = Math.abs(a.y - b.y);
  return {x, y, w, h};
}

// Utility: check if object is fully inside rectangle
function isObjectFullyInRect(o, rect){
  const b = getBounds(o);
  return (
    b.x >= rect.x &&
    b.y >= rect.y &&
    b.x + b.w <= rect.x + rect.w &&
    b.y + b.h <= rect.y + rect.h
  );
}

function pathForStroke(o){
  const p = o.props.path || [];
  if(p.length === 0) return;
  ctx.beginPath();
  if(o.props.strokeType === 'rectangle' && p.length >= 2) {
    // Create rectangle path for selection
    const start = p[0];
    const end = p[1];
    const x = Math.min(start.x, end.x);
    const y = Math.min(start.y, end.y);
    const w = Math.abs(end.x - start.x);
    const h = Math.abs(end.y - start.y);
    ctx.rect(x, y, w, h);
  } else if(o.props.strokeType === 'arrow' && p.length >= 2) {
    // Create bounding box path for arrow selection
    const start = p[0];
    const end = p[1];
    const x = Math.min(start.x, end.x);
    const y = Math.min(start.y, end.y);
    const w = Math.abs(end.x - start.x);
    const h = Math.abs(end.y - start.y);
    ctx.rect(x, y, w, h);
  } else if(o.props.strokeType === 'roundedRectangle' && p.length >= 2) {
    // Create bounding box path for rounded rectangle selection
    const start = p[0];
    const end = p[1];
    const x = Math.min(start.x, end.x);
    const y = Math.min(start.y, end.y);
    const w = Math.abs(end.x - start.x);
    const h = Math.abs(end.y - start.y);
    ctx.rect(x, y, w, h);
  } else if(o.props.strokeType === 'decision' && p.length >= 2) {
    // Create bounding box path for decision selection
    const start = p[0];
    const end = p[1];
    const x = Math.min(start.x, end.x);
    const y = Math.min(start.y, end.y);
    const w = Math.abs(end.x - start.x);
    const h = Math.abs(end.y - start.y);
    ctx.rect(x, y, w, h);
  } else if(o.props.strokeType === 'inputOutput' && p.length >= 2) {
    // Create bounding box path for input/output selection
    const start = p[0];
    const end = p[1];
    const x = Math.min(start.x, end.x);
    const y = Math.min(start.y, end.y);
    const w = Math.abs(end.x - start.x);
    const h = Math.abs(end.y - start.y);
    ctx.rect(x, y, w, h);
  } else if(o.props.strokeType === 'connector' && p.length >= 2) {
    // Create bounding box path for connector selection
    const start = p[0];
    const end = p[1];
    const x = Math.min(start.x, end.x);
    const y = Math.min(start.y, end.y);
    const w = Math.abs(end.x - start.x);
    const h = Math.abs(end.y - start.y);
    ctx.rect(x, y, w, h);
  } else {
    // Default path creation for lines and other strokes
    ctx.moveTo(p[0].x, p[0].y);
    for(let i=1; i<p.length; i++) ctx.lineTo(p[i].x, p[i].y);
  }
}

function isPointOnObject(o, pt){
  if(o.type==='stroke'){
    if(o.props.strokeType === 'rectangle') {
      // For rectangles, check if point is inside the rectangle bounds
      const p = o.props.path || [];
      if(p.length >= 2) {
        const start = p[0];
        const end = p[1];
        const x = Math.min(start.x, end.x);
        const y = Math.min(start.y, end.y);
        const w = Math.abs(end.x - start.x);
        const h = Math.abs(end.y - start.y);
        return pt.x >= x && pt.x <= x + w && pt.y >= y && pt.y <= y + h;
      }
      return false;
    } else if(o.props.strokeType === 'arrow') {
      // For arrows, check if point is inside the bounding box
      const p = o.props.path || [];
      if(p.length >= 2) {
        const start = p[0];
        const end = p[1];
        const x = Math.min(start.x, end.x);
        const y = Math.min(start.y, end.y);
        const w = Math.abs(end.x - start.x);
        const h = Math.abs(end.y - start.y);
        return pt.x >= x && pt.x <= x + w && pt.y >= y && pt.y <= y + h;
      }
      return false;
    } else if(o.props.strokeType === 'roundedRectangle') {
      // For rounded rectangles, check if point is inside the bounding box
      const p = o.props.path || [];
      if(p.length >= 2) {
        const start = p[0];
        const end = p[1];
        const x = Math.min(start.x, end.x);
        const y = Math.min(start.y, end.y);
        const w = Math.abs(end.x - start.x);
        const h = Math.abs(end.y - start.y);
        return pt.x >= x && pt.x <= x + w && pt.y >= y && pt.y <= y + h;
      }
      return false;
    } else if(o.props.strokeType === 'decision') {
      // For decision shapes, check if point is inside the bounding box
      const p = o.props.path || [];
      if(p.length >= 2) {
        const start = p[0];
        const end = p[1];
        const x = Math.min(start.x, end.x);
        const y = Math.min(start.y, end.y);
        const w = Math.abs(end.x - start.x);
        const h = Math.abs(end.y - start.y);
        return pt.x >= x && pt.x <= x + w && pt.y >= y && pt.y <= y + h;
      }
      return false;
    } else if(o.props.strokeType === 'inputOutput') {
      // For input/output shapes, check if point is inside the bounding box
      const p = o.props.path || [];
      if(p.length >= 2) {
        const start = p[0];
        const end = p[1];
        const x = Math.min(start.x, end.x);
        const y = Math.min(start.y, end.y);
        const w = Math.abs(end.x - start.x);
        const h = Math.abs(end.y - start.y);
        return pt.x >= x && pt.x <= x + w && pt.y >= y && pt.y <= y + h;
      }
      return false;
    } else if(o.props.strokeType === 'connector') {
      // For connector shapes, check if point is inside the bounding box
      const p = o.props.path || [];
      if(p.length >= 2) {
        const start = p[0];
        const end = p[1];
        const x = Math.min(start.x, end.x);
        const y = Math.min(start.y, end.y);
        const w = Math.abs(end.x - start.x);
        const h = Math.abs(end.y - start.y);
        return pt.x >= x && pt.x <= x + w && pt.y >= y && pt.y <= y + h;
      }
      return false;
    } else {
      // For other strokes, check if point is on the stroke path
      const p = o.props.path || [];
      if(p.length === 0) return false;
      ctx.save();
      pathForStroke(o);
      ctx.lineJoin='round'; ctx.lineCap='round'; ctx.lineWidth=o.props.size;
      const hit=ctx.isPointInStroke(pt.x,pt.y);
      ctx.restore();
      return hit;
    }
  } else if(o.type==='image' || o.type==='text'){
    const b=getBounds(o); return pt.x>=b.x && pt.x<=b.x+b.w && pt.y>=b.y && pt.y<=b.y+b.h;
  }
  return false;
}

function pickTopMost(pt){
  const sorted=[...objects].sort((a,b)=> (b.layer-a.layer) || (b.id-a.id));
  return sorted.find(o=> isPointOnObject(o, pt));
}

/* ======= Enhanced Resizing Logic ======= */
function performResize(o, handleType, currentMouse, initialMouse, initialBounds, shiftPressed) {
  const dx = currentMouse.x - initialMouse.x;
  const dy = currentMouse.y - initialMouse.y;
  
  if(o.type === 'image') {
    let newX = initialBounds.x;
    let newY = initialBounds.y;
    let newW = initialBounds.w;
    let newH = initialBounds.h;
    
    switch(handleType) {
      case 'resize-nw':
        newX = initialBounds.x + dx;
        newY = initialBounds.y + dy;
        newW = initialBounds.w - dx;
        newH = initialBounds.h - dy;
        break;
      case 'resize-ne':
        newY = initialBounds.y + dy;
        newW = initialBounds.w + dx;
        newH = initialBounds.h - dy;
        break;
      case 'resize-sw':
        newX = initialBounds.x + dx;
        newW = initialBounds.w - dx;
        newH = initialBounds.h + dy;
        break;
      case 'resize-se':
        newW = initialBounds.w + dx;
        newH = initialBounds.h + dy;
        break;
      case 'resize-n':
        newY = initialBounds.y + dy;
        newH = initialBounds.h - dy;
        break;
      case 'resize-s':
        newH = initialBounds.h + dy;
        break;
      case 'resize-e':
        newW = initialBounds.w + dx;
        break;
      case 'resize-w':
        newX = initialBounds.x + dx;
        newW = initialBounds.w - dx;
        break;
    }
    
    if(shiftPressed) {
      // Constrain aspect ratio when Shift is pressed
      const originalRatio = initialBounds.w / initialBounds.h;
      
      if(handleType.includes('nw') || handleType.includes('ne') || handleType.includes('sw') || handleType.includes('se')) {
        // For corner handles, maintain aspect ratio
        const scaleX = newW / initialBounds.w;
        const scaleY = newH / initialBounds.h;
        const scale = Math.max(Math.abs(scaleX), Math.abs(scaleY));
        
        newW = initialBounds.w * scale * (scaleX >= 0 ? 1 : -1);
        newH = initialBounds.h * scale * (scaleY >= 0 ? 1 : -1);
        
        if(handleType === 'resize-nw') {
          newX = initialBounds.x + initialBounds.w - newW;
          newY = initialBounds.y + initialBounds.h - newH;
        } else if(handleType === 'resize-ne') {
          newY = initialBounds.y + initialBounds.h - newH;
        } else if(handleType === 'resize-sw') {
          newX = initialBounds.x + initialBounds.w - newW;
        }
      } else if(handleType === 'resize-n' || handleType === 'resize-s') {
        // For top/bottom handles, scale width proportionally
        newW = newH * originalRatio;
        if(handleType === 'resize-n') {
          newY = initialBounds.y + initialBounds.h - newH;
        }
      } else if(handleType === 'resize-e' || handleType === 'resize-w') {
        // For left/right handles, scale height proportionally
        newH = newW / originalRatio;
        if(handleType === 'resize-w') {
          newX = initialBounds.x + initialBounds.w - newW;
        }
      }
    }
    
    newW = Math.max(10, Math.abs(newW));
    newH = Math.max(10, Math.abs(newH));
    
    o.props.x = newX;
    o.props.y = newY;
    o.props.w = newW;
    o.props.h = newH;
    
  } else if(o.type === 'text') {
    const scale = 1 + dx/200;
    const newFontSize = Math.max(8, Math.min(160, (initialBounds.fontSize || 24) * scale));
    o.props.fontSize = newFontSize;
    
  } else if(o.type === 'stroke') {
    let scaleX = 1, scaleY = 1;
    let offsetX = 0, offsetY = 0;
    
    switch(handleType) {
      case 'resize-nw':
        scaleX = (initialBounds.w - dx) / initialBounds.w;
        scaleY = (initialBounds.h - dy) / initialBounds.h;
        offsetX = dx;
        offsetY = dy;
        break;
      case 'resize-ne':
        scaleX = (initialBounds.w + dx) / initialBounds.w;
        scaleY = (initialBounds.h - dy) / initialBounds.h;
        offsetY = dy;
        break;
      case 'resize-sw':
        scaleX = (initialBounds.w - dx) / initialBounds.w;
        scaleY = (initialBounds.h + dy) / initialBounds.h;
        offsetX = dx;
        break;
      case 'resize-se':
        scaleX = (initialBounds.w + dx) / initialBounds.w;
        scaleY = (initialBounds.h + dy) / initialBounds.h;
        break;
      case 'resize-n':
        scaleY = (initialBounds.h - dy) / initialBounds.h;
        offsetY = dy;
        break;
      case 'resize-s':
        scaleY = (initialBounds.h + dy) / initialBounds.h;
        break;
      case 'resize-e':
        scaleX = (initialBounds.w + dx) / initialBounds.w;
        break;
      case 'resize-w':
        scaleX = (initialBounds.w - dx) / initialBounds.w;
        offsetX = dx;
        break;
    }
    
    if(shiftPressed) {
      // Constrain aspect ratio for strokes when Shift is pressed
      const originalRatio = initialBounds.w / initialBounds.h;
      
      if(handleType.includes('nw') || handleType.includes('ne') || handleType.includes('sw') || handleType.includes('se')) {
        // For corner handles, use uniform scaling
        const scale = Math.max(Math.abs(scaleX), Math.abs(scaleY));
        scaleX = scale * (scaleX >= 0 ? 1 : -1);
        scaleY = scale * (scaleY >= 0 ? 1 : -1);
      } else if(handleType === 'resize-n' || handleType === 'resize-s') {
        // For top/bottom handles, scale width proportionally
        scaleX = scaleY;
      } else if(handleType === 'resize-e' || handleType === 'resize-w') {
        // For left/right handles, scale height proportionally
        scaleY = scaleX;
      }
    }
    
    const originalPath = originalPositions.get(o.id) || o.props.path;
    o.props.path = originalPath.map(pt => ({
      x: initialBounds.x + offsetX + (pt.x - initialBounds.x) * scaleX,
      y: initialBounds.y + offsetY + (pt.y - initialBounds.y) * scaleY
    }));
  }
}

/* ======= Text Editor ======= */
const textEditorOverlay = document.getElementById('text-editor-overlay');
const textEditorTextarea = document.getElementById('text-editor-textarea');
const textEditorSave = document.getElementById('text-editor-save');
const textEditorCancel = document.getElementById('text-editor-cancel');

function openTextEditor(textObj) {
  editingTextId = textObj.id;
  const objText = textObj.props?.text || textObj.text || '';
  textEditorTextarea.value = objText;
  textEditorOverlay.style.display = 'flex';
  requestAnimationFrame(() => {
    resizeTextEditorTextarea();
    textEditorTextarea.focus();
    textEditorTextarea.select();
  });
}

function closeTextEditor(save = false) {
  if (save && editingTextId) {
    const o = findById(editingTextId);
    if (o) {
      const newText = textEditorTextarea.value.trim();

      // Always use global settings from settings modal, just like paste functionality
      console.log('=== TEXT EDITOR SAVE ===');
      console.log('Using global settings from settings modal');
      console.log('userPrefs.maxWordsPerLine:', userPrefs.maxWordsPerLine);
      console.log('userPrefs.maxLinesPerPage:', userPrefs.maxLinesPerPage);

      // Remove the original text object
      const index = objects.findIndex(obj => obj.id === editingTextId);
      if (index !== -1) {
        objects.splice(index, 1);
      }

      // Use the existing addTextAcrossPages function with global settings
      const objFontSize = o.props?.fontSize || o.fontSize || 24;
      const objX = o.props?.x || o.x || 0;
      const objY = o.props?.y || o.y || 0;
      addTextAcrossPages(newText, objFontSize, objX, objY);
    }
  }
  textEditorOverlay.style.display = 'none';
  editingTextId = null;
  textEditorTextarea.value = '';
}

textEditorSave.addEventListener('click', () => closeTextEditor(true));
textEditorCancel.addEventListener('click', () => closeTextEditor(false));
textEditorOverlay.addEventListener('click', (e) => { if (e.target === textEditorOverlay) closeTextEditor(false); });
textEditorTextarea.addEventListener('input', resizeTextEditorTextarea);
textEditorTextarea.addEventListener('focus', resizeTextEditorTextarea);
textEditorTextarea.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closeTextEditor(false);
  else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) closeTextEditor(true);
});

function resizeTextEditorTextarea() {
  if (!textEditorTextarea) return;
  textEditorTextarea.style.height = 'auto';
  const maxHeight = Math.max(window.innerHeight * 0.7, 240);
  const scrollHeight = textEditorTextarea.scrollHeight;
  const nextHeight = Math.min(scrollHeight, maxHeight);
  textEditorTextarea.style.height = `${nextHeight}px`;
  textEditorTextarea.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
}

/* ======= Crop Modal ======= */
let croppingImageId = null;
let cropSelection = { x: 0, y: 0, w: 100, h: 100 };
let isDraggingCrop = false;
let isResizingCrop = false;
let cropDragStart = { x: 0, y: 0 };
let resizeHandle = null;

function openCropModal(imageObj) {
  croppingImageId = imageObj.id;
  const img = document.getElementById('crop-image');
  
  // Create a new image to load the source and get dimensions
  const tempImg = new Image();
  tempImg.onload = () => {
    img.src = imageObj.props.src;
    cropSelection = { x: 0, y: 0, w: tempImg.naturalWidth, h: tempImg.naturalHeight };
    updateCropSelection();
    document.getElementById('crop-overlay').style.display = 'flex';
  };
  tempImg.src = imageObj.props.src;
}

function closeCropModal(save = false) {
  if (save && croppingImageId) {
    const o = findById(croppingImageId);
    if (o) {
      const img = document.getElementById('crop-image');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = cropSelection.w;
      canvas.height = cropSelection.h;
      
      ctx.drawImage(img, 
        cropSelection.x, cropSelection.y, cropSelection.w, cropSelection.h,
        0, 0, cropSelection.w, cropSelection.h
      );
      
      const croppedDataUrl = canvas.toDataURL('image/png');
      
      // Update the image object with cropped version
      const prev = { src: o.props.src, w: o.props.w, h: o.props.h };
      const next = { src: croppedDataUrl, w: cropSelection.w, h: cropSelection.h };
      o.props.src = croppedDataUrl;
      o.props.w = cropSelection.w;
      o.props.h = cropSelection.h;
      commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
    }
  }
  document.getElementById('crop-overlay').style.display = 'none';
  croppingImageId = null;
}

function updateCropSelection() {
  const img = document.getElementById('crop-image');
  const selection = document.getElementById('crop-selection');
  const handles = document.querySelectorAll('.crop-handle');
  
  if (!img || !img.complete || img.naturalWidth === 0) return;
  
  const scaleX = img.clientWidth / img.naturalWidth;
  const scaleY = img.clientHeight / img.naturalHeight;
  
  selection.style.left = (cropSelection.x * scaleX) + 'px';
  selection.style.top = (cropSelection.y * scaleY) + 'px';
  selection.style.width = (cropSelection.w * scaleX) + 'px';
  selection.style.height = (cropSelection.h * scaleY) + 'px';
  
  // Update handles
  const handlesPos = [
    { handle: 'nw', x: cropSelection.x, y: cropSelection.y },
    { handle: 'ne', x: cropSelection.x + cropSelection.w, y: cropSelection.y },
    { handle: 'sw', x: cropSelection.x, y: cropSelection.y + cropSelection.h },
    { handle: 'se', x: cropSelection.x + cropSelection.w, y: cropSelection.y + cropSelection.h }
  ];
  
  handlesPos.forEach(({ handle, x, y }) => {
    const handleEl = document.querySelector(`[data-handle="${handle}"]`);
    handleEl.style.left = (x * scaleX - 5) + 'px';
    handleEl.style.top = (y * scaleY - 5) + 'px';
  });
}

// Event listeners for crop modal
document.getElementById('crop-save').addEventListener('click', () => closeCropModal(true));
document.getElementById('crop-cancel').addEventListener('click', () => closeCropModal(false));
document.getElementById('crop-overlay').addEventListener('click', (e) => { 
  if (e.target === document.getElementById('crop-overlay')) closeCropModal(false); 
});

// Add keyboard support for crop modal
document.addEventListener('keydown', async (e) => {
  if (document.getElementById('crop-overlay').style.display === 'flex') {
    if (e.key === 'Escape') {
      closeCropModal(false);
    } else if (e.key === 'Enter') {
      closeCropModal(true);
    }
  }
});

// Crop selection dragging
document.getElementById('crop-selection').addEventListener('mousedown', (e) => {
  isDraggingCrop = true;
  cropDragStart = { x: e.clientX, y: e.clientY };
  e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
  if (!isDraggingCrop && !isResizingCrop) return;
  
  const img = document.getElementById('crop-image');
  const scaleX = img.naturalWidth / img.clientWidth;
  const scaleY = img.naturalHeight / img.clientHeight;
  const deltaX = (e.clientX - cropDragStart.x) * scaleX;
  const deltaY = (e.clientY - cropDragStart.y) * scaleY;
  
  if (isDraggingCrop) {
    cropSelection.x = Math.max(0, Math.min(img.naturalWidth - cropSelection.w, cropSelection.x + deltaX));
    cropSelection.y = Math.max(0, Math.min(img.naturalHeight - cropSelection.h, cropSelection.y + deltaY));
  } else if (isResizingCrop && resizeHandle) {
    // Handle resizing based on which corner is being dragged
    const minSize = 10;
    if (resizeHandle.includes('n')) {
      const newY = Math.max(0, cropSelection.y + deltaY);
      const newH = Math.max(minSize, cropSelection.h - (newY - cropSelection.y));
      cropSelection.y = newY;
      cropSelection.h = newH;
    }
    if (resizeHandle.includes('s')) {
      cropSelection.h = Math.max(minSize, cropSelection.h + deltaY);
    }
    if (resizeHandle.includes('w')) {
      const newX = Math.max(0, cropSelection.x + deltaX);
      const newW = Math.max(minSize, cropSelection.w - (newX - cropSelection.x));
      cropSelection.x = newX;
      cropSelection.w = newW;
    }
    if (resizeHandle.includes('e')) {
      cropSelection.w = Math.max(minSize, cropSelection.w + deltaX);
    }
    
    // Ensure selection stays within image bounds
    cropSelection.x = Math.max(0, Math.min(img.naturalWidth - cropSelection.w, cropSelection.x));
    cropSelection.y = Math.max(0, Math.min(img.naturalHeight - cropSelection.h, cropSelection.y));
    cropSelection.w = Math.min(cropSelection.w, img.naturalWidth - cropSelection.x);
    cropSelection.h = Math.min(cropSelection.h, img.naturalHeight - cropSelection.y);
  }
  
  cropDragStart = { x: e.clientX, y: e.clientY };
  updateCropSelection();
});

document.addEventListener('mouseup', () => {
  isDraggingCrop = false;
  isResizingCrop = false;
  resizeHandle = null;
});

// Handle resizing
document.querySelectorAll('.crop-handle').forEach(handle => {
  handle.addEventListener('mousedown', (e) => {
    isResizingCrop = true;
    resizeHandle = e.target.dataset.handle;
    cropDragStart = { x: e.clientX, y: e.clientY };
    e.preventDefault();
    e.stopPropagation();
  });
});

/* ======= Keyboard Events ======= */
document.addEventListener('keydown', async (e) => {
  if(e.key === 'Shift') {
    shiftPressed = true;
    updateStatus();
  }
  
  // Escape to toggle between select tool and deselect all mode
  if (e.key === 'Escape') {
    e.preventDefault();
    
    // Check if we're in text box placement mode first
    if (window.pendingTextBoxShape) {
      window.pendingTextBoxShape = null;
      if (canvas) {
        canvas.style.cursor = 'default';
      }
      console.log('Text box placement cancelled');
      return;
    }
    
    const currentTool = document.getElementById('tool-select').value;
    
    if (currentTool === 'select') {
      // If already in select mode, deselect all and visually deselect tools
      selectedId = null;
      multiSelectedIds.clear();
      deselectAllTools();
      resetUIControls();
      // Hide context menu when deselecting
      ctxMenu.style.display='none';
      ctxMenu.removeAttribute('data-multiselect');
      ctxMenu.removeAttribute('data-paste-only');
      redraw();
    } else {
      // If in any other tool or no tool selected, switch to select tool
      s('select');
    }
  }
  
  // Delete to delete selected elements
  if (e.key === 'Delete' ) {
    e.preventDefault();
    if (multiSelectedIds.size > 1) {
      // Multi-selection delete
      const selectedObjects = Array.from(multiSelectedIds).map(id => findById(id)).filter(Boolean);
      if (selectedObjects.length > 0) {
        const deletes = selectedObjects.map(o => ({ type:"delete", object: structuredCloneSafe(o) }));
        executeCommand({ type:"batch", commands: deletes });
        multiSelectedIds.clear();
        selectedId = null;
        resetUIControls();
        redraw();
      }
    } else if (selectedId !== null) {
      // Single selection delete
      const o = findById(selectedId);
      if (o) {
        executeCommand({type:"delete", object: structuredCloneSafe(o)});
        selectedId = null;
        resetUIControls();
        redraw();
      }
    }
  }
  
  // Ctrl+E to insert page at current location
  if (e.ctrlKey && e.key === 'e') {
    e.preventDefault();
    insertPageAtCurrentLocation();
  }
  
  // Ctrl+Z to undo
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  
  // Ctrl+Y to redo
  if (e.ctrlKey && e.key === 'y') {
    e.preventDefault();
    redo();
  }
  
  // Ctrl+Shift+T or Alt+T to insert text
  if ((e.ctrlKey && e.shiftKey && e.key === 'T') || (e.altKey && e.key === 't')) {
    e.preventDefault();
    e.stopImmediatePropagation();
    const fs = parseInt(document.getElementById('text-size').value, 10) || 24;
    const textObj = {
      id: nextObjectId++,
      type: 'text',
      layer: BASE_OBJECT_LAYER,
      props: { text: 'Text', x: 100, y: 100, fontSize: fs, color: color }
    };
    addObject(textObj);
    selectedId = textObj.id;
    openTextEditor(textObj);
    redraw();
    return; // Exit early to prevent any further processing
  }
  
  // Ctrl+I to insert image
  if (e.ctrlKey && e.key === 'i') {
    e.preventDefault();
    document.getElementById('image-upload').click();
  }
  
  // Ctrl+S to save
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    document.getElementById('save-btn').click();
  }
  
  // Ctrl+P to print as PDF
  if (e.ctrlKey && e.key === 'p') {
    e.preventDefault();
    printToPDF();
  }
  
  // Ctrl+C to copy selected objects
  if (e.ctrlKey && e.key === 'c') {
    e.preventDefault();
    if (multiSelectedIds.size > 1) {
      // Copy multi-selected objects
      const selectedObjects = Array.from(multiSelectedIds).map(id => findById(id)).filter(Boolean);
      if (selectedObjects.length > 0) {
        globalClipboard = selectedObjects.map(o => structuredCloneSafe(o));
        markInternalClipboardUpdated();
      }
    } else if (selectedId !== null) {
      // Copy single selected object
      const o = findById(selectedId);
      if (o) {
        globalClipboard = [structuredCloneSafe(o)];
        markInternalClipboardUpdated();
      }
    }
  }
  
  // Ctrl+V to paste at current mouse position
  if (e.ctrlKey && e.key === 'v') {
    e.preventDefault();
    const pastePosition = currentMousePosition || { x: 100, y: 100 };
    await handlePasteAtPosition(pastePosition);
  }
  
  // Arrow keys to move selected objects (like in Paint) - always prevent default scrolling
  if (!e.ctrlKey && !e.altKey && !e.metaKey) {
    let deltaX = 0;
    let deltaY = 0;
    const moveStep = e.shiftKey ? 10 : 1; // Hold Shift for bigger moves (10px), normal for precise (1px)
    
    switch (e.key) {
      case 'ArrowUp':
        e.preventDefault();
        deltaY = -moveStep;
        break;
      case 'ArrowDown':
        e.preventDefault();
        deltaY = moveStep;
        break;
      case 'ArrowLeft':
        e.preventDefault();
        deltaX = -moveStep;
        break;
      case 'ArrowRight':
        e.preventDefault();
        deltaX = moveStep;
        break;
    }
    
    // Only move objects if there are selected objects
    if ((multiSelectedIds.size > 0 || selectedId !== null) && (deltaX !== 0 || deltaY !== 0)) {
      const moves = [];
      
      // Handle multi-selection
      if (multiSelectedIds.size > 0) {
        for (const id of multiSelectedIds) {
          const obj = findById(id);
          if (obj) {
            const original = structuredCloneSafe(obj);
            if (obj.type === 'text' || obj.type === 'image') {
              obj.props.x += deltaX;
              obj.props.y += deltaY;
            } else if (obj.type === 'stroke') {
              // Move all points in the stroke
              obj.props.path = obj.props.path.map(point => ({
                x: point.x + deltaX,
                y: point.y + deltaY
              }));
            }
            moves.push({ type: "update", object: original, newObject: structuredCloneSafe(obj) });
          }
        }
      } 
      // Handle single selection
      else if (selectedId !== null) {
        const obj = findById(selectedId);
        if (obj) {
          const original = structuredCloneSafe(obj);
          if (obj.type === 'text' || obj.type === 'image') {
            obj.props.x += deltaX;
            obj.props.y += deltaY;
          } else if (obj.type === 'stroke') {
            // Move all points in the stroke
            obj.props.path = obj.props.path.map(point => ({
              x: point.x + deltaX,
              y: point.y + deltaY
            }));
          }
          moves.push({ type: "update", object: original, newObject: structuredCloneSafe(obj) });
        }
      }
      
      if (moves.length > 0) {
        executeCommand({ type: "batch", commands: moves });
        redraw();
      }
    }
  }
});

document.addEventListener('keyup', (e) => {
  if(e.key === 'Shift') {
    shiftPressed = false;
    updateStatus();
  }
});

// Track mouse position for keyboard paste
document.addEventListener('mousemove', (e) => {
  currentMousePosition = toCanvasXY(e);
});

/* ======= Page Control Event Listeners ======= */
document.getElementById('prev-page').addEventListener('click', () => {
  if (currentPageIndex > 0) {
    switchToPage(currentPageIndex - 1);
  }
});

document.getElementById('next-page').addEventListener('click', () => {
  if (currentPageIndex < pages.length - 1) {
    switchToPage(currentPageIndex + 1);
  }
});

document.getElementById('add-page-before').addEventListener('click', insertPageBeforeCurrent);
document.getElementById('add-page').addEventListener('click', insertPageAtCurrentLocation);
document.getElementById('delete-page').addEventListener('click', deleteCurrentPage);

/* ======= Enhanced Pointer Events ======= */
canvas.addEventListener('pointerdown', (ev)=>{
  canvas.setPointerCapture(ev.pointerId);
  const p=toCanvasXY(ev);
  const t = Date.now();

  // Check if we're in text box placement mode
  if (window.pendingTextBoxShape) {
    placeTextBox(p.x, p.y, window.pendingTextBoxShape);
    return;
  }

  // Multi-selection handles (MOVE THIS ABOVE rect-select!)
  if (multiSelectedIds.size > 1 && currentHandles && currentHandles.length) {
    const h = getMultiHandleAt(currentHandles, p);
    if (h) {
      if (h.type === "multi-move") {
        multiMoving = true;
        multiMoveStart = p;
        multiMoveOriginals = Array.from(multiSelectedIds).map(id => {
          const o = findById(id);
          if (!o) return null;
          if (o.type === "image" || o.type === "text") {
            return {id: o.id, x: o.props.x, y: o.props.y};
          } else if (o.type === "stroke") {
            return {id: o.id, path: o.props.path.map(pt => ({x: pt.x, y: pt.y}))};
          }
        }).filter(Boolean);
        canvas.style.cursor = "grabbing";
        return;
      }
      if (h.type === "multi-rotate") {
        multiRotating = true;
        multiRotateStart = p;
        multiRotateOriginals = Array.from(multiSelectedIds).map(id => {
          const o = findById(id);
          if (!o) return null;
          if (o.type === "image" || o.type === "text") {
            return {id: o.id, rotation: o.props.rotation || 0, center: getObjectCenter(o)};
          } else if (o.type === "stroke") {
            return {id: o.id, path: o.props.path.map(pt => ({x: pt.x, y: pt.y})), center: getObjectCenter(o)};
          }
        }).filter(Boolean);
        canvas.style.cursor = "grab";
        return;
      }
      if (h.type === "multi-menu") {
        ctxMenu.style.display='block';
        positionContextMenu(ev.clientX, ev.clientY);
        ctxMenu.setAttribute('data-multiselect', multiSelectedIds.size > 1 ? 'true' : 'false');
        
        // Hide "Edit Text" and "Paste" for multi-selection
        ctxMenu.querySelector('[data-cmd="edit-text"]').style.display = 'none';
        ctxMenu.querySelector('[data-cmd="paste"]').style.display = 'none';
        // Show all other buttons explicitly
        ctxMenu.querySelector('[data-cmd="copy"]').style.display = 'block';
        ctxMenu.querySelector('[data-cmd="duplicate"]').style.display = 'block';
        ctxMenu.querySelector('[data-cmd="layer-up"]').style.display = 'block';
        ctxMenu.querySelector('[data-cmd="layer-down"]').style.display = 'block';
        ctxMenu.querySelector('[data-cmd="front"]').style.display = 'block';
        ctxMenu.querySelector('[data-cmd="back"]').style.display = 'block';
        ctxMenu.querySelector('[data-cmd="delete"]').style.display = 'block';
        
        ctxMenu.removeAttribute('data-paste-only');
        ignoreNextCtxMenuClose = true;
        return;
      }
    }
  }

  if(currentTool==='rect-select'){
    rectSelecting = true;
    rectSelectStart = toCanvasXY(ev);
    rectSelectEnd = rectSelectStart;
    multiSelectedIds.clear();
    redraw();
    return;
  }

  if(currentTool==='pen' || currentTool==='marker' || currentTool==='highlighter'){
    drawing=true;
    currentStroke=[p];
    selectedId=null;
    redraw();
    return;
  }

  // Generic handler for all shape tools (including line)
  if(currentTool==='line' || isShapeTool(currentTool)){
    drawing=true;
    currentStroke = [p, p]; // Start with two identical points for preview
    selectedId=null;
    redraw();
    return;
  }

  if(currentTool==='text'){
    // Create text object at click position with current settings
    const fs = parseInt(document.getElementById('text-size').value, 10) || 24;
    const textObj = {
      id: nextObjectId++,
      type: 'text',
      layer: BASE_OBJECT_LAYER,
      props: { 
        text: 'Text', 
        x: p.x, 
        y: p.y, 
        fontSize: fs, 
        color: color,
        maxWordsPerLine: userPrefs.maxWordsPerLine || 10,
        maxLinesPerPage: userPrefs.maxLinesPerPage || 25
      }
    };
    addObject(textObj);
    selectedId = textObj.id;
    
    // Immediately open text editor
    openTextEditor(textObj);
    redraw();
    return;
  }

  if(currentTool==='select'){
    if(selectedId && currentHandles.length > 0){
      const handle = getHandleAt(currentHandles, p);
      if(handle){
        const o = findById(selectedId);
        if(o){
          if(handle.type.startsWith('resize')){
            resizing = true;
            activeHandle = handle.type;
            dragStart = p;
            initialMouse = {x: p.x, y: p.y};
            initialBounds = getBounds(o);
            
            if(o.type === 'image') {
              aspectRatio = initialBounds.w / initialBounds.h;
              originalPositions.set(o.id, {
                x: o.props.x, y: o.props.y,
                w: o.props.w, h: o.props.h
              });
            } else if(o.type === 'text') {
              originalPositions.set(o.id, {
                fontSize: o.props.fontSize || 24
              });
              initialBounds.fontSize = o.props.fontSize || 24;
            } else if(o.type === 'stroke') {
              originalPositions.set(o.id, (o.props.path || []).map(pt => ({x: pt.x, y: pt.y})));
            }
            
          } else if(handle.type === 'rotate'){
            rotating = true;
            dragStart = p;
            const center = getObjectCenter(o);
            const initialAngle = Math.atan2(p.y - center.y, p.x - center.x);
            
            originalPositions.set(o.id, {
              rotation: o.props.rotation || 0,
              center: center,
              initialAngle: initialAngle,
              path: o.type === 'stroke' ? (o.props.path || []).map(pt => ({x: pt.x, y: pt.y})) : null
            });
          }
          return;
        }
      }
    }

    const hit=pickTopMost(p);
    if(hit){
      const isDoubleClick = hit === lastClickTarget && (t - lastClickTime) < DOUBLE_CLICK_TIME;
      if(isDoubleClick && hit.type === 'text'){
        openTextEditor(hit);
        return;
      }

      // Ctrl+click for add/remove from multi-selection
      if(ev.ctrlKey || ev.metaKey) {
        if(multiSelectedIds.has(hit.id)) {
          // Remove from selection
          multiSelectedIds.delete(hit.id);
          if(selectedId === hit.id) {
            selectedId = null;
          }
        } else {
          // Add to selection
          multiSelectedIds.add(hit.id);
          // If we had a single selection, add it to multi-selection too
          if(selectedId && selectedId !== hit.id && !multiSelectedIds.has(selectedId)) {
            multiSelectedIds.add(selectedId);
          }
          selectedId = null; // Clear single selection when multi-selecting
        }
        
        // If only one item left in multi-selection, make it single selection
        if(multiSelectedIds.size === 1) {
          selectedId = Array.from(multiSelectedIds)[0];
          multiSelectedIds.clear();
        } else if(multiSelectedIds.size === 0) {
          selectedId = null;
        }
        
        resetUIControls();
        redraw();
        return;
      }

      // Normal selection (clear multi-selection unless clicking on already selected item)
      if(multiSelectedIds.size > 1 && multiSelectedIds.has(hit.id)) {
        // Clicking on an item that's already in multi-selection - keep multi-selection
        selectedId = null;
      } else {
        // Regular single selection
        selectedId=hit.id;
        multiSelectedIds.clear();
      }
      
      lastClickTarget = hit;
      lastClickTime = t;

      // Only setup dragging if we have a single selection (not multi-selection)
      if(selectedId && multiSelectedIds.size === 0) {
        const o=hit;
        if(o.type==='image' || o.type==='text'){
          dragOffset={dx:p.x-o.props.x, dy:p.y-o.props.y};
          originalPositions.set(o.id, { x: o.props.x, y: o.props.y });
        } else if(o.type==='stroke'){
          originalPositions.set(o.id, (o.props.path||[]).map(pt=>({x:pt.x,y:pt.y})));
          dragOffset={dx:0, dy:0};
        }
        dragging=true; dragStart=p; canvas.style.cursor='grabbing';
      }
      redraw();
    } else {
      // Clicked on empty space - clear all selections unless Ctrl is held
      if(!(ev.ctrlKey || ev.metaKey)) {
        selectedId=null; 
        multiSelectedIds.clear();
        dragging=false;
        lastClickTarget = null;
        resetUIControls();
        redraw();
      }
    }
  }

  if(currentTool==='rect-select'){
    rectSelecting = true;
    rectSelectStart = toCanvasXY(ev);
    rectSelectEnd = rectSelectStart;
    multiSelectedIds.clear();
    redraw();
    return;
  }

  // Multi-selection handles
  if (multiSelectedIds.size > 1 && currentHandles && currentHandles.length) {
    const h = getMultiHandleAt(currentHandles, p);
    if (h) {
      if (h.type === "multi-move") {
        multiMoving = true;
        multiMoveStart = p;
        multiMoveOriginals = Array.from(multiSelectedIds).map(id => {
          const o = findById(id);
          if (!o) return null;
          if (o.type === "image" || o.type === "text") {
            return {id: o.id, x: o.props.x, y: o.props.y};
          } else if (o.type === "stroke") {
            return {id: o.id, path: o.props.path.map(pt => ({x: pt.x, y: pt.y}))};
          }
        }).filter(Boolean);
        canvas.style.cursor = "grabbing";
        return;
      }
      if (h.type === "multi-rotate") {
        multiRotating = true;
        multiRotateStart = p;
        multiRotateOriginals = Array.from(multiSelectedIds).map(id => {
          const o = findById(id);
          if (!o) return null;
          if (o.type === "image" || o.type === "text") {
            return {id: o.id, rotation: o.props.rotation || 0, center: getObjectCenter(o)};
          } else if (o.type === "stroke") {
            return {id: o.id, path: o.props.path.map(pt => ({x: pt.x, y: pt.y})), center: getObjectCenter(o)};
          }
        }).filter(Boolean);
        canvas.style.cursor = "grab";
        return;
      }
      if (h.type === "multi-menu") {
        ctxMenu.style.display='block';
        positionContextMenu(ev.clientX, ev.clientY);
        ctxMenu.setAttribute('data-multiselect', multiSelectedIds.size > 1 ? 'true' : 'false');
        ctxMenu.querySelector('[data-cmd="edit-text"]').style.display = multiSelectedIds.size === 1 && findById(Array.from(multiSelectedIds)[0]).type === 'text' ? 'block' : 'none';
        ignoreNextCtxMenuClose = true;
        return;
      }
    }
  }
});

canvas.addEventListener('pointermove', (ev)=>{
  const p=toCanvasXY(ev);

  if(drawing){
    if(currentTool === 'line' && currentStroke && currentStroke.length >= 2){
      // For line tool, update the end point to show preview
      currentStroke[1] = p;
      redraw();
    } else if(isShapeTool(currentTool) && currentStroke && currentStroke.length >= 2){
      // For shape tools, update the end point to show preview
      currentStroke[1] = p;
      redraw();
    } else if(currentStroke){
      // For other drawing tools, add points normally
      currentStroke.push(p);
      redraw();
    }
    return;
  }

  if(resizing && selectedId!=null && activeHandle){
    const o = findById(selectedId); 
    if(!o) return;
    
    performResize(o, activeHandle, p, initialMouse, initialBounds, shiftPressed);
    redraw();
    return;
  }

  if(rotating && selectedId!=null){
    const o = findById(selectedId); if(!o) return;
    const orig = originalPositions.get(o.id); if(!orig) return;

    const currentAngle = Math.atan2(p.y - orig.center.y, p.x - orig.center.x);
    performRotation(o, currentAngle, orig.initialAngle);
    redraw();
    return;
  }

  if(dragging && selectedId!=null){
    const o=findById(selectedId); if(!o) return;

    if(o.type==='image' || o.type==='text'){
      o.props.x=p.x-(dragOffset?.dx||0);
      o.props.y=p.y-(dragOffset?.dy||0);
      redraw();
    } else if(o.type==='stroke'){
      const orig=originalPositions.get(o.id) || (o.props.path||[]);
      const dx=p.x-dragStart.x, dy=p.y-dragStart.y;
      o.props.path=orig.map(pt=>({x:pt.x+dx,y:pt.y+dy}));
      redraw();
    }
    return;
  }

  // Multi-move
  if (multiMoving && multiMoveOriginals) {
    const dx = p.x - multiMoveStart.x;
    const dy = p.y - multiMoveStart.y;
    multiMoveOriginals.forEach(orig => {
      const o = findById(orig.id);
      if (!o) return;
      if (o.type === "image" || o.type === "text") {
        o.props.x = orig.x + dx;
        o.props.y = orig.y + dy;
      } else if (o.type === "stroke") {
        o.props.path = orig.path.map(pt => ({x: pt.x + dx, y: pt.y + dy}));
      }
    });
    redraw();
    return;
  }
  // Multi-rotate
  if (multiRotating && multiRotateOriginals) {
    multiRotateOriginals.forEach(orig => {
      const o = findById(orig.id);
      if (!o) return;
      const center = orig.center;
      const startAngle = Math.atan2(multiRotateStart.y - center.y, multiRotateStart.x - center.x);
      const currentAngle = Math.atan2(p.y - center.y, p.x - center.x);
      const delta = currentAngle - startAngle;
      if (o.type === "image" || o.type === "text") {
        o.props.rotation = orig.rotation + delta;
      } else if (o.type === "stroke") {
        o.props.path = orig.path.map(pt => rotatePoint(pt.x, pt.y, center.x, center.y, delta));
      }
    });
    redraw();
    return;
  }

  if(currentTool==='select'){
    let cursor = 'default';
    let newHoveredHandle = null;
    
    // Check for multi-selection handles first
    if(multiSelectedIds.size > 1 && currentHandles && currentHandles.length > 0){
      const h = getMultiHandleAt(currentHandles, p);
      if(h){
        newHoveredHandle = h.type;
        if(h.type === 'multi-move') cursor = 'move';
        else if(h.type === 'multi-rotate') cursor = 'grab';
        else if(h.type === 'multi-menu') cursor = 'pointer';
      }
    }
    
    // Update hover state and redraw if changed
    if(newHoveredHandle !== hoveredMultiHandle) {
      hoveredMultiHandle = newHoveredHandle;
      redraw();
    }
    
    // Single selection handles
    if(cursor === 'default' && selectedId && currentHandles.length > 0){
      const handle = getHandleAt(currentHandles, p);
      if(handle){
        cursor = getCursorForHandle(handle.type);
      }
    }
    
    // Default object hover
    if(cursor === 'default'){
      const hit=pickTopMost(p); cursor = hit ? 'grab' : 'default';
    }
    canvas.style.cursor = cursor;
  } else if(currentTool==='rect-select' && rectSelecting){
    canvas.style.cursor = 'crosshair';
    rectSelectEnd = p;
    redraw();
    return;
  }
});

canvas.addEventListener('pointerup', (ev)=>{
  if(drawing){
    drawing=false;
    if(currentTool === 'line' && currentStroke && currentStroke.length >= 2){
      // For line tool, always create a stroke (even if it's just a dot)
      const strokeObj = {
        id: nextObjectId++,
        type: 'stroke',
        layer: BASE_STROKE_LAYER,
        props: { 
          path: [...currentStroke], 
          color: color, 
          size: size,
          strokeType: currentTool,
          transparency: currentTransparency
        }
      };
      addObject(strokeObj);
      selectedId = strokeObj.id;
    } else if(isShapeTool(currentTool) && currentStroke && currentStroke.length >= 2){
      // For all shape tools, create a shape stroke
      const strokeObj = {
        id: nextObjectId++,
        type: 'stroke',
        layer: BASE_STROKE_LAYER,
        props: { 
          path: [...currentStroke], 
          color: color, 
          size: size,
          strokeType: currentTool,
          transparency: currentTransparency
        }
      };
      addObject(strokeObj);
      selectedId = strokeObj.id;
    } else if(currentStroke && currentStroke.length > 1){
      // For other drawing tools, only create if dragged
      const strokeObj = {
        id: nextObjectId++,
        type: 'stroke',
        layer: BASE_STROKE_LAYER,
        props: { 
          path: [...currentStroke], 
          color: color, 
          size: size,
          strokeType: currentTool,  // Store whether it's pen, marker, or highlighter
          transparency: currentTransparency  // Store current transparency
        }
      };
      addObject(strokeObj);
      selectedId = strokeObj.id;
    }
    currentStroke = null;
  }

  if((dragging || resizing || rotating) && selectedId!=null){
    const o = findById(selectedId);
    const orig = originalPositions.get(selectedId);
    if(o && orig){
      if(dragging){
        if(o.type==='image' || o.type==='text'){
          const prev = { x: orig.x, y: orig.y };
          const next = { x: o.props.x, y: o.props.y };
          commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
        } else if(o.type==='stroke'){
          const prev = { path: orig };
          const next = { path: o.props.path.map(pt=>({x:pt.x,y:pt.y})) };
          commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
        }
      } else if(resizing){
        if(o.type==='image'){
          const prev = { x: orig.x, y: orig.y, w: orig.w, h: orig.h };
          const next = { x: o.props.x, y: o.props.y, w: o.props.w, h: o.props.h };
          commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
        } else if(o.type==='text'){
          const prev = { fontSize: orig.fontSize };
          const next = { fontSize: o.props.fontSize };
          commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
        } else if(o.type==='stroke'){
          const prev = { path: orig };
          const next = { path: o.props.path.map(pt=>({x:pt.x,y:pt.y})) };
          commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
        }
      } else if(rotating){
        const prev = { rotation: orig.rotation || 0 };
        const next = { rotation: o.props.rotation || 0 };
        commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
      }
    }
    originalPositions.delete(selectedId);
  }

  if(currentTool==='rect-select' && rectSelecting){
    rectSelecting = false;
    rectSelectEnd = toCanvasXY(ev);
    multiSelectedIds.clear();
    const selRect = getRectFromPoints(rectSelectStart, rectSelectEnd);
    let selectedObjects = [];
    for(const o of objects){
      if(isObjectFullyInRect(o, selRect)){
        multiSelectedIds.add(o.id);
        selectedObjects.push(o);
      }
    }
    // If only one object is selected, set selectedId for status bar details
    if(selectedObjects.length === 1){
      selectedId = selectedObjects[0].id;
    } else {
      selectedId = null;
    }
    redraw();
    return;
  }

  if (multiMoving && multiMoveOriginals) {
    multiMoving = false;
    multiMoveStart = null;
    multiMoveOriginals = null;
    canvas.style.cursor = "default";
    redraw();
    return;
  }
  if (multiRotating && multiRotateOriginals) {
    multiRotating = false;
    multiRotateStart = null;
    multiRotateOriginals = null;
    canvas.style.cursor = "default";
    redraw();
    return;
  }

  dragging=false; resizing=false; rotating=false;
  activeHandle=null; initialBounds=null; initialMouse=null; aspectRatio=null;
  dragStart=null; dragOffset=null;
  canvas.style.cursor='default';
  redraw();
});

/* ======= Context menu ======= */
const ctxMenu=document.getElementById('ctx');

// Helper function to position context menu intelligently
function positionContextMenu(clientX, clientY) {
  const menuHeight = ctxMenu.offsetHeight || 250; // Estimate if not rendered yet
  const menuWidth = ctxMenu.offsetWidth || 150;
  const viewportHeight = window.innerHeight;
  const viewportWidth = window.innerWidth;
  
  let left = clientX;
  let top = clientY;
  
  // Check if menu would go off the right edge
  if (left + menuWidth > viewportWidth) {
    left = clientX - menuWidth;
    // Ensure menu doesn't go off the left edge
    if (left < 0) {
      left = 0;
    }
  }
  
  // Check if click is in lower half of screen
  if (clientY > viewportHeight / 2) {
    // Position menu above the click point
    top = clientY - menuHeight;
    // Ensure menu doesn't go off the top edge
    if (top < 0) {
      top = 0;
    }
  } else {
    // Position menu below the click point (original behavior)
    // Ensure menu doesn't go off the bottom edge
    if (top + menuHeight > viewportHeight) {
      top = viewportHeight - menuHeight;
    }
  }
  
  ctxMenu.style.left = left + 'px';
  ctxMenu.style.top = top + 'px';
}
canvas.addEventListener('contextmenu', (ev)=>{
  ev.preventDefault();
  const p=toCanvasXY(ev);
  contextMenuPosition = p; // Store position for paste operations

  // Multi-selection context menu logic (triggered for any tool if multiSelectedIds.size > 1)
  if (multiSelectedIds.size > 1) {
    // Check if right-click is on any selected object
    const hit = Array.from(multiSelectedIds).map(id => findById(id)).find(o => isPointOnObject(o, p));
    if (hit) {
      // Do NOT clear selection!
      selectedId = null; // No single selection
      redraw();

      // Hide "Edit Text" and "Paste" for multi-selection
      ctxMenu.querySelector('[data-cmd="edit-text"]').style.display = 'none';
      ctxMenu.querySelector('[data-cmd="paste"]').style.display = 'none';
      // Show all other buttons explicitly
      ctxMenu.querySelector('[data-cmd="copy"]').style.display = 'block';
      ctxMenu.querySelector('[data-cmd="duplicate"]').style.display = 'block';
      ctxMenu.querySelector('[data-cmd="layer-up"]').style.display = 'block';
      ctxMenu.querySelector('[data-cmd="layer-down"]').style.display = 'block';
      ctxMenu.querySelector('[data-cmd="front"]').style.display = 'block';
      ctxMenu.querySelector('[data-cmd="back"]').style.display = 'block';
      ctxMenu.querySelector('[data-cmd="delete"]').style.display = 'block';

      ctxMenu.style.display='block';
      positionContextMenu(ev.clientX, ev.clientY);
      ctxMenu.setAttribute('data-multiselect', 'true');
      ctxMenu.removeAttribute('data-paste-only');
      return;
    }
    // If right-click is NOT on any selected object, fall through and clear selection below
  }

  // Single selection fallback
  const hit=pickTopMost(p);
  if(hit){
    selectedId=hit.id;
    redraw();

    const editTextBtn = ctxMenu.querySelector('[data-cmd="edit-text"]');
    editTextBtn.style.display = hit.type === 'text' ? 'block' : 'none';
    const cropBtn = ctxMenu.querySelector('[data-cmd="crop"]');
    cropBtn.style.display = hit.type === 'image' ? 'block' : 'none';
    // Show all other buttons explicitly for single selection
    ctxMenu.querySelector('[data-cmd="copy"]').style.display = 'block';
    ctxMenu.querySelector('[data-cmd="paste"]').style.display = 'block';
    ctxMenu.querySelector('[data-cmd="duplicate"]').style.display = 'block';
    ctxMenu.querySelector('[data-cmd="layer-up"]').style.display = 'block';
    ctxMenu.querySelector('[data-cmd="layer-down"]').style.display = 'block';
    ctxMenu.querySelector('[data-cmd="front"]').style.display = 'block';
    ctxMenu.querySelector('[data-cmd="back"]').style.display = 'block';
    ctxMenu.querySelector('[data-cmd="delete"]').style.display = 'block';

    ctxMenu.style.display='block';
    positionContextMenu(ev.clientX, ev.clientY);
    ctxMenu.removeAttribute('data-multiselect');
    ctxMenu.removeAttribute('data-paste-only');
  } else {
    // Only clear selection if right-click is NOT on any selected object
    selectedId = null;
    multiSelectedIds.clear();
    redraw();

    // Always offer paste when right-clicking empty space
    ctxMenu.querySelectorAll('button').forEach(btn => {
      btn.style.display = btn.dataset.cmd === 'paste' ? 'block' : 'none';
    });
    ctxMenu.style.display='block';
    positionContextMenu(ev.clientX, ev.clientY);
    ctxMenu.setAttribute('data-paste-only', 'true');
    ctxMenu.removeAttribute('data-multiselect');
    return;
  }
});
document.addEventListener('click', (e)=>{
  if (ignoreNextCtxMenuClose) {
    ignoreNextCtxMenuClose = false;
    return;
  }
  if(!ctxMenu.contains(e.target)) {
    ctxMenu.style.display='none';
    ctxMenu.removeAttribute('data-multiselect');
    ctxMenu.removeAttribute('data-paste-only');
  }
});

ctxMenu.addEventListener('click', async (e)=>{
  const cmdKey = e.target?.dataset?.cmd;
  if (!cmdKey) return;

  // Paste-only mode (right-click on empty space with clipboard content)
  if (ctxMenu.getAttribute('data-paste-only') === 'true') {
    if (cmdKey === 'paste') {
      await handlePasteAtPosition(contextMenuPosition);
    }
    ctxMenu.style.display='none';
    redraw();
    return;
  }

  // Multi-selection mode
  if (ctxMenu.getAttribute('data-multiselect') === 'true' && multiSelectedIds.size > 1) {
    const selectedObjects = Array.from(multiSelectedIds).map(id => findById(id)).filter(Boolean);

    if (cmdKey === 'duplicate') {
      const positionedObjects = positionPastedObjects(selectedObjects, contextMenuPosition);
      const clones = positionedObjects.map(obj => {
        obj.id = nextObjectId++;
        return {type:"add", object: obj};
      });
      executeCommand({ type:"batch", commands: clones });
      multiSelectedIds = new Set(clones.map(c => c.object.id));
      selectedId = null;
      resetUIControls();
      resetUIControls();
    } else if (cmdKey === 'copy') {
      globalClipboard = selectedObjects.map(o => structuredCloneSafe(o));
      markInternalClipboardUpdated();
    } else if (cmdKey === 'paste') {
      await handlePasteAtPosition(contextMenuPosition);
    } else if (cmdKey === 'delete') {
      const deletes = selectedObjects.map(o => ({ type:"delete", object: structuredCloneSafe(o) }));
      executeCommand({ type:"batch", commands: deletes });
      multiSelectedIds.clear();
      selectedId = null;
      resetUIControls();
    } else if (cmdKey === 'layer-up' || cmdKey === 'layer-down' || cmdKey === 'front' || cmdKey === 'back') {
      const layerCmds = selectedObjects.map(o => {
        const prev = { layer: o.layer };
        let newLayer = o.layer;
        if(cmdKey==='layer-up') newLayer = o.layer + 1;
        else if(cmdKey==='layer-down') newLayer = o.layer - 1;
        else if(cmdKey==='front') newLayer = (objects.length? Math.max(...objects.map(x=>x.layer)) : 0) + 1;
        else if(cmdKey==='back') newLayer = (objects.length? Math.min(...objects.map(x=>x.layer)) : 0) - 1;
        return { type:"updateRoot", id:o.id, prev, next:{ layer:newLayer } };
      });
      executeCommand({ type:"batch", commands: layerCmds });
    }
    ctxMenu.style.display='none';
    ctxMenu.removeAttribute('data-multiselect');
    ctxMenu.removeAttribute('data-paste-only');
    redraw();
    return;
  }

  // Single selection mode (existing code)
  if(selectedId==null) return;
  const o=findById(selectedId); if(!o) return;

  if(cmdKey === 'edit-text' && o.type === 'text'){
    openTextEditor(o);
    ctxMenu.style.display='none';
    return;
  }

  if(cmdKey === 'crop' && o.type === 'image'){
    openCropModal(o);
    ctxMenu.style.display='none';
    return;
  }

  if(cmdKey==='layer-up' || cmdKey==='layer-down' || cmdKey==='front' || cmdKey==='back'){
    const prev = { layer: o.layer };
    let newLayer = o.layer;

    if(cmdKey==='layer-up') newLayer = o.layer + 1;
    else if(cmdKey==='layer-down') newLayer = o.layer - 1;
    else if(cmdKey==='front') newLayer = (objects.length? Math.max(...objects.map(x=>x.layer)) : 0) + 1;
    else if(cmdKey==='back') newLayer = (objects.length? Math.min(...objects.map(x=>x.layer)) : 0) - 1;

    executeCommand({ type:"updateRoot", id:o.id, prev, next:{ layer:newLayer } });
  } else if(cmdKey==='duplicate'){
    const positionedObjects = positionPastedObjects([o], contextMenuPosition);
    const clone = positionedObjects[0];
    clone.id = nextObjectId++;
    addObject(clone);
    selectedId = clone.id;
  } else if(cmdKey==='copy'){
    globalClipboard = [structuredCloneSafe(o)];
    markInternalClipboardUpdated();
  } else if(cmdKey==='paste'){
    await handlePasteAtPosition(contextMenuPosition);
  } else if(cmdKey==='delete'){
    removeByIdCmd(o);
    selectedId = null;
    resetUIControls();
  }

  ctxMenu.style.display='none';
  ctxMenu.removeAttribute('data-multiselect');
  ctxMenu.removeAttribute('data-paste-only');
  redraw();
});

/* ======= Enhanced UI controls with live editing ======= */
document.getElementById('tool-select').addEventListener('change',e=>{
  currentTool=e.target.value;
  
  // Load tool-specific color when changing tools
  if (toolColors[currentTool]) {
    color = toolColors[currentTool];
    document.getElementById('color-picker').value = color;
    document.getElementById('current-tool-color').style.backgroundColor = color;
  }
  
  // Load tool-specific size when changing tools
  if (toolSizes[currentTool]) {
    size = toolSizes[currentTool];
    document.getElementById('size-range').value = size;
  }
  
  updateCursor();
  if(currentTool !== 'select') {
    selectedId = null;
    resetUIControls();
    redraw();
  }
});

function applyColorToSelection(newColor) {
  const selectionIds = (multiSelectedIds && multiSelectedIds.size > 0)
    ? Array.from(multiSelectedIds)
    : (selectedId ? [selectedId] : []);

  const commands = [];

  selectionIds.forEach(id => {
    const o = findById(id);
    if (!o || (o.type !== 'stroke' && o.type !== 'text')) return;
    if (!o.props) o.props = {};

    const prevColor = o.props.color ?? o.color;
    const prev = { color: prevColor };
    const next = { color: newColor };

    o.props.color = newColor;
    commands.push({ type: "updateProps", id: o.id, prev, next });
  });

  if (commands.length === 1) {
    commitAppliedChange(commands[0]);
  } else if (commands.length > 1) {
    commitAppliedChange({ type: "batch", commands });
  }
}

document.getElementById('color-picker').addEventListener('input',e=> {
  const newColor = e.target.value;
  color = newColor;
  document.getElementById('current-tool-color').style.backgroundColor = newColor;
  
  // Save color to current tool's memory
  if (toolColors[currentTool]) {
    toolColors[currentTool] = newColor;
  }
  
  applyColorToSelection(newColor);
});

document.getElementById('size-range').addEventListener('input',e=> {
  const newSize = parseInt(e.target.value,10)||4;
  size = newSize;
  
  // Save size to current tool's memory
  if (toolSizes[currentTool]) {
    toolSizes[currentTool] = newSize;
  }
  
  if(selectedId) {
    const o = findById(selectedId);
    if(o && o.type === 'stroke') {
      const prev = { size: o.props.size };
      const next = { size: newSize };
      o.props.size = newSize;
      commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
    }
  }
});

document.getElementById('transparency-range').addEventListener('input', e => {
  const newTransparency = parseFloat(e.target.value) || 0.4;
  currentTransparency = newTransparency;
  document.getElementById('transparency-value').textContent = Math.round(newTransparency * 100) + '%';
  
  // Save transparency to current tool's memory
  if (toolTransparencies[currentTool]) {
    toolTransparencies[currentTool] = newTransparency;
  }
  
  if(selectedId) {
    const o = findById(selectedId);
    if(o && o.type === 'stroke' && (o.props.strokeType === 'highlighter' || o.props.strokeType === 'marker')) {
      const prev = { transparency: o.props.transparency };
      const next = { transparency: newTransparency };
      o.props.transparency = newTransparency;
      commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
      redraw();
    }
  }
});

document.getElementById('text-size').addEventListener('input',e=> {
  const newFontSize = parseInt(e.target.value, 10) || 24;
  
  if(selectedId) {
    const o = findById(selectedId);
    if(o && o.type === 'text') {
      const prev = { fontSize: o.props.fontSize };
      const next = { fontSize: newFontSize };
      o.props.fontSize = newFontSize;
      commitAppliedChange({ type:"updateProps", id:o.id, prev, next });
    }
  }
});

document.getElementById('undo-btn').addEventListener('click',undo);
document.getElementById('redo-btn').addEventListener('click',redo);

document.getElementById('image-upload').addEventListener('change',(e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const reader=new FileReader();
  reader.onload=(ev)=>{
    const img=new Image(); img.src=ev.target.result; img.onload=()=>{
      // Create canvas for compression
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Calculate size for 1.2MP equivalent (approximately 1200x1000 max)
      const targetPixels = 1.2 * 1000000; // 1.2 megapixels
      const currentPixels = img.width * img.height;
      
      let w = img.width;
      let h = img.height;
      
      // If image is larger than 1.2MP, scale it down
      if (currentPixels > targetPixels) {
        const scale = Math.sqrt(targetPixels / currentPixels);
        w = Math.round(img.width * scale);
        h = Math.round(img.height * scale);
      }
      
      // Set canvas size
      canvas.width = w;
      canvas.height = h;
      
      // Draw and compress image
      ctx.drawImage(img, 0, 0, w, h);
      
      // Convert to JPEG with 70% quality
      const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
      
      console.log(`[IMAGE] Original: ${img.width}x${img.height} (${Math.round(currentPixels/1000000*100)/100}MP), Resized: ${w}x${h} (${Math.round((w*h)/1000000*100)/100}MP)`);
      console.log(`[IMAGE] Size - Original: ${ev.target.result.length} bytes, Compressed: ${compressedDataUrl.length} bytes, Reduction: ${Math.round((1 - compressedDataUrl.length/ev.target.result.length) * 100)}%`);
      
      // Warn if still too large
      if(compressedDataUrl.length > 500000) {
        console.warn('[IMAGE] Large image detected (>500KB), may cause save issues');
      }
      
      addObject({id:nextObjectId++, type:'image', layer:BASE_OBJECT_LAYER, props:{src:compressedDataUrl, x:50, y:160, w, h}});
    };
  };
  reader.readAsDataURL(f);
});

document.getElementById('clear-btn').addEventListener('click',()=>{
  if(!confirm('Clear this page? This cannot be undone.')) return;
  if(objects.length === 0) return;

  const deleteCommands = objects.map(o => ({ type:"delete", object: structuredCloneSafe(o) }));
  executeCommand({ type:"batch", commands: deleteCommands });
  selectedId=null;
  resetUIControls();
});

/* ======= Save Success Notification ======= */
function showSaveSuccess(fileSize) {
  // Format file size
  let sizeText = '';
  if (fileSize < 1024) {
    sizeText = `${fileSize} bytes`;
  } else if (fileSize < 1024 * 1024) {
    sizeText = `${(fileSize / 1024).toFixed(1)} KB`;
  } else {
    sizeText = `${(fileSize / (1024 * 1024)).toFixed(1)} MB`;
  }
  
  // Use telemetry panel instead of popup notification
  if (window.TelemetryPanel) {
    window.TelemetryPanel.setIdle(`Saved whiteboard (${sizeText})`);
  }
}

/* ======= Save / Export PNG ======= */
document.getElementById('save-btn').addEventListener('click', async ()=>{
  // Show loading overlay
  document.getElementById('save-loading-overlay').style.display = 'flex';
  
  console.log('=== SAVE BUTTON CLICKED ===');
  console.log('Current objects before save:', objects);
  console.log('Current objects count:', objects.length);
  
  // Log detailed object summary
  if (objects.length > 0) {
    console.log('OBJECTS SUMMARY:');
    objects.forEach((obj, index) => {
      console.log(`  [${index}] ID: ${obj.id}, Type: ${obj.type}, Layer: ${obj.layer}`);
      if (obj.type === 'stroke' && obj.props?.path) {
        console.log(`    - Stroke with ${obj.props.path.length} points, color: ${obj.props.color}, size: ${obj.props.size}`);
      } else if (obj.type === 'text' && obj.props?.text) {
        console.log(`    - Text: "${obj.props.text}" at (${obj.props.x}, ${obj.props.y}), size: ${obj.props.fontSize}`);
      } else if (obj.props) {
        console.log(`    - Props keys: ${Object.keys(obj.props).join(', ')}`);
      }
    });
  } else {
    console.log('NO OBJECTS TO SAVE!');
  }
  
  saveCurrentPageState();
  console.log('Current page state saved, pages:', pages);
  console.log('Current page objects after saveCurrentPageState:', pages[currentPageIndex]?.objects);
  console.log('DETAILED PAGE CONTENT:');
  pages.forEach((page, index) => {
    console.log(`Page ${index}:`, JSON.stringify(page, null, 2));
  });
  
  // Log summary of all pages
  console.log('PAGES SUMMARY:');
  pages.forEach((page, index) => {
    console.log(`  Page ${index + 1} (ID: ${page.id}): ${page.objects?.length || 0} objects`);
    if (page.objects && page.objects.length > 0) {
      page.objects.forEach((obj, objIndex) => {
        console.log(`    [${objIndex}] ${obj.type} (ID: ${obj.id})`);
      });
    }
  });
  
  const payloadData = {
    version: 3,
    pages: pages,
    currentPageIndex: currentPageIndex,
    nextPageId: nextPageId,
    nextObjectId: nextObjectId
  };
  
  console.log('PAYLOAD DATA BEFORE STRINGIFY:', payloadData);
  
  const payload = JSON.stringify(payloadData);
  
  console.log('Payload created, length:', payload.length);
  console.log('Payload preview:', payload.substring(0, 500));
  
  // Sync the visible title and description inputs with the hidden form inputs
  const visibleTitle = document.getElementById('board-title').value || 'Miopage';
  const visibleDescription = document.getElementById('board-description').value || '';
  document.getElementById('title-input').value = visibleTitle;
  document.getElementById('description-input').value = visibleDescription;
  document.getElementById('content-input').value = payload;
  
  const form=document.getElementById('save-form');
  console.log('Form action:', form.action);
  
  try{
    const fm=new FormData();
    fm.append('title', visibleTitle);
    fm.append('description', visibleDescription);
    fm.append('content', payload);
    fm.append('folder_id', document.getElementById('folder-id-input').value);
    
    console.log('Sending AJAX request to:', form.action);
    console.log('Payload size (bytes):', payload.length);
    
    // Add timeout for large requests - increased for server idle scenarios
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 120000); // 120 second timeout for PythonAnywhere idle startup
    
    const res=await fetch(form.action,{
      method:'POST',
      body:fm,
      headers:{'X-Requested-With':'XMLHttpRequest'},
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    console.log('Response status:', res.status);
    
    if(res.ok){ 
      const responseData = await res.json();
      console.log('Save response:', responseData);
      
      // If this was a new board creation, update the form action for future saves
      if(responseData.board_id && form.action.includes('/new')) {
        const newAction = form.action.replace('/new', `/edit/${responseData.board_id}`);
        form.action = newAction;
        console.log('Updated form action to:', newAction);
        
        // Also update the browser URL to the edit page
        const newUrl = window.location.origin + `/boards/edit/${responseData.board_id}`;
        window.history.replaceState({}, '', newUrl);
        console.log('Updated browser URL to:', newUrl);
      }
      
      //alert('Saved successfully!'); 
      showSaveSuccess(payload.length);
      // Hide loading overlay
      document.getElementById('save-loading-overlay').style.display = 'none'; 
    } else { 
      console.error('AJAX failed with status:', res.status);
      const errorText = await res.text();
      console.error('Error response:', errorText);
      
      if(res.status === 413) {
        alert('Error: Board content too large. Try reducing image quality or removing some images.');
        // Hide loading overlay
        document.getElementById('save-loading-overlay').style.display = 'none';
        return;
      }
      
      console.log('Falling back to form submit');
      // Hide loading overlay before form submit
      document.getElementById('save-loading-overlay').style.display = 'none';
      form.submit(); 
    }
  }catch(e){ 
    console.error('Save error:', e);
    
    if(e.name === 'AbortError') {
      alert('Save timeout: Board content too large. Try reducing image quality or removing some images.');
      // Hide loading overlay
      document.getElementById('save-loading-overlay').style.display = 'none';
      return;
    }
    
    alert('Save failed. Trying alternative method...');
    // Hide loading overlay before form submit
    document.getElementById('save-loading-overlay').style.display = 'none';
    form.submit(); 
  }
});

document.getElementById('export-png').addEventListener('click',()=>{
  redraw();
  const data=canvas.toDataURL('image/png');
  const a=document.createElement('a'); a.href=data; a.download=`page-${currentPageIndex + 1}.png`; a.click();
});

document.getElementById('print-pdf').addEventListener('click', printToPDF);

/* ======= Export/Import JSON ======= */
function exportJSON(){
  saveCurrentPageState();
  const choice = confirm("OK = Save with history\nCancel = Save without history");
  let data;
  if(choice){
    data = {
      version: 3,
      pages: pages,
      currentPageIndex: currentPageIndex,
      nextPageId: nextPageId,
      nextObjectId: nextObjectId
    };
  } else {
    data = {
      version: 3,
      pages: pages.map(page => ({
        id: page.id,
        objects: page.objects
      })),
       currentPageIndex: currentPageIndex,
      nextPageId: nextPageId,
      nextObjectId: nextObjectId
    };
  }

  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'multi-page-whiteboard.json';
  a.click();
  URL.revokeObjectURL(url);
}

function importJSON(){
  document.getElementById('importFile').value = "";
  document.getElementById('importFile').click();
}

function handleImportFile(evt){
  const file = evt.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);

      if(data.pages && Array.isArray(data.pages)) {
        // Multi-page format
        pages = data.pages.map(page => ({
          id: page.id,
          objects: page.objects || [],
          undoStack: page.undoStack || [],
          redoStack: page.redoStack || []
        }));
        currentPageIndex = Math.max(0, Math.min(data.currentPageIndex || 0, pages.length - 1));
        nextPageId = data.nextPageId || (pages.reduce((m,p)=>Math.max(m,p.id||0),0)+1) || 1;
        nextObjectId = data.nextObjectId || 1;
        
        if(pages.length === 0) {
          pages = [createNewPage()];
          currentPageIndex = 0;
        }
        
      } else if(data.objects && Array.isArray(data.objects)) {
        // Legacy single-page format
        pages = [{
          id: nextPageId++,
          objects: data.objects,
          undoStack: data.undoStack || [],
          redoStack: data.redoStack || []
        }];
        currentPageIndex = 0;
        nextObjectId = data.nextId || (data.objects.reduce((m,o)=>Math.max(m,o.id||0),0)+1) || 1;
        
      } else {
        alert("Invalid file format.");
        return;
      }

      loadPageState(currentPageIndex);
      updatePageControls();
    } catch(err){
      alert("Error reading JSON: " + err);
    }
  };
  reader.readAsText(file);
}

/* ======= Print to PDF ======= */
async function printToPDF() {
    try {
        // Save current page before starting
        saveCurrentPageState();
        
        // Get the board title
        const boardTitle = document.getElementById('board-title').value || 'Miopage';
        
        // Get canvas dimensions
        const canvas = document.getElementById('board-canvas');
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        
        // Create PDF document with landscape orientation to better fit canvas
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: canvasWidth > canvasHeight ? 'landscape' : 'portrait',
            unit: 'mm',
            format: 'a4'
        });
        
        // Get PDF dimensions
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        
        // Calculate scale to fit canvas in PDF while maintaining aspect ratio
        const scaleX = pdfWidth / canvasWidth;
        const scaleY = pdfHeight / canvasHeight;
        const scale = Math.min(scaleX, scaleY) * 0.9; // 0.9 to add some margin
        
        const scaledWidth = canvasWidth * scale;
        const scaledHeight = canvasHeight * scale;
        
        // Center the image on the page
        const offsetX = (pdfWidth - scaledWidth) / 2;
        const offsetY = (pdfHeight - scaledHeight) / 2;
        
        // Store original page index
        const originalPageIndex = currentPageIndex;
        
        // Process each page
        for (let i = 0; i < pages.length; i++) {
            // Switch to the page
            switchToPage(i);
            
            // Force a redraw to ensure current content is rendered
            redraw();
            
            // Wait a bit for rendering to complete
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Convert canvas to image data
            const imgData = canvas.toDataURL('image/png', 1.0);
            
            // Add new page if not the first page
            if (i > 0) {
                pdf.addPage();
            }
            
            // Add title at the top of each page
            pdf.setFontSize(12);
            pdf.setTextColor(0, 0, 0);
            pdf.text(`${boardTitle}`, 10, 10);
            
            // Add the canvas image
            pdf.addImage(imgData, 'PNG', offsetX, offsetY + 15, scaledWidth, scaledHeight);
            
            // Add page number at bottom
            pdf.setFontSize(10);
            pdf.text(`Page ${i + 1}`, pdfWidth - 20, pdfHeight - 5);
        }
        
        // Return to original page
        switchToPage(originalPageIndex);
        
        // Save the PDF
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        pdf.save(`${boardTitle}_${timestamp}.pdf`);
        
        // Show success message
        alert(`PDF exported successfully!\n${pages.length} page(s) included.`);
        
    } catch (error) {
        console.error('PDF export error:', error);
        alert('Error exporting PDF: ' + error.message);
    }
}

/// ###############################################################

/* ======= Line-based Text Splitting Helper ======= */
function splitTextByLines(text, maxLinesPerPage = 25) {
  console.log('=== SPLIT BY LINES DEBUG ===');
  console.log('Input text lines:', text.split('\n').length);
  console.log('maxLinesPerPage:', maxLinesPerPage);
  
  // Split text into lines while preserving original formatting
  const lines = text.split('\n');
  
  console.log('Total lines to split:', lines.length);
  
  // If total lines fit in one page, return as single chunk
  if (lines.length <= maxLinesPerPage) {
    console.log('Fits in one page, returning single chunk');
    return [text];
  }
  
  console.log('Multiple pages needed, splitting...');
  
  // Split lines into page chunks
  const pageChunks = [];
  for (let i = 0; i < lines.length; i += maxLinesPerPage) {
    const pageLines = lines.slice(i, i + maxLinesPerPage);
    pageChunks.push(pageLines.join('\n'));
    console.log(`Chunk ${pageChunks.length}: ${pageLines.length} lines`);
  }
  
  console.log('Final chunks:', pageChunks.length);
  return pageChunks;
}

function addTextAcrossPages(text, fontSize, startX = 50, startY = 160) {
  // Get current settings from modal - make sure they're loaded
  console.log('=== SETTINGS CHECK ===');
  console.log('userPrefs object:', userPrefs);
  console.log('userPrefs.maxWordsPerLine:', userPrefs.maxWordsPerLine);
  console.log('userPrefs.maxLinesPerPage:', userPrefs.maxLinesPerPage);
  
  const maxWordsPerLine = userPrefs.maxWordsPerLine || 10;
  const maxLinesPerPage = userPrefs.maxLinesPerPage || 25;
  
  console.log('=== TEXT SPLITTING DEBUG ===');
  console.log('Using maxWordsPerLine:', maxWordsPerLine);
  console.log('Using maxLinesPerPage:', maxLinesPerPage);
  console.log('Original text lines:', text.split('\n').length);
  
  // First apply word wrapping to break long lines
  const wrappedText = autoWrapTextByWords(text, maxWordsPerLine);
  
  console.log('After word wrapping lines:', wrappedText.split('\n').length);
  console.log('Wrapped text preview:', wrappedText.substring(0, 200));
  
  const chunks = splitTextByLines(wrappedText, maxLinesPerPage);
  
  console.log('Number of chunks:', chunks.length);
  console.log('Chunk lengths:', chunks.map(c => c.split('\n').length));
  
  if (chunks.length === 1) {
    // Single page - add normally with current settings stored
    addObject({
      id: nextObjectId++,
      type: "text",
      layer: BASE_OBJECT_LAYER,
      props: {
        text: chunks[0],
        x: startX,
        y: startY,
        fontSize: fontSize,
        color: color,
        maxWordsPerLine: maxWordsPerLine,
        maxLinesPerPage: maxLinesPerPage
      }
    });
    return 1;
  }
  
  // Multiple pages needed
  const totalLines = wrappedText.split('\n').length;
  const confirmed = confirm(
    `This text will be split across multiple pages.\n\n` +
    `Original text lines: ${text.split('\n').length}\n` +
    `After word wrapping (${maxWordsPerLine} words/line): ${totalLines} lines\n` +
    `Pages needed: ${chunks.length}\n` +
    `Lines per page: ${maxLinesPerPage}\n\n` +
    `Continue?`
  );
  
  if (!confirmed) return 0;
  
  // Save current state
  saveCurrentPageState();
  
    // Add text to current page (first chunk) with settings stored
  addObject({
    id: nextObjectId++,
    type: "text",
    layer: BASE_OBJECT_LAYER,
    props: {
      text: chunks[0],
      x: startX,
      y: startY,
      fontSize: fontSize,
      color: color,
      maxWordsPerLine: maxWordsPerLine,
      maxLinesPerPage: maxLinesPerPage
    }
  });  // Create new pages for remaining chunks
  for (let i = 1; i < chunks.length; i++) {
    // Save current page state before creating new page
    saveCurrentPageState();
    
    // Create new page using Ctrl+E functionality
    const newPage = createNewPage();
    pages.splice(currentPageIndex + 1, 0, newPage);
    currentPageIndex = currentPageIndex + 1;
    
    // Load the new page
    loadPageState(currentPageIndex);
    
    // Add text chunk to new page with settings stored
    addObject({
      id: nextObjectId++,
      type: "text",
      layer: BASE_OBJECT_LAYER,
      props: {
        text: chunks[i],
        x: startX,
        y: startY,
        fontSize: fontSize,
        color: color,
        maxWordsPerLine: maxWordsPerLine,
        maxLinesPerPage: maxLinesPerPage
      }
    });
  }
  
  updatePageControls();
  redraw();
  
  // Show success message
  alert(`Text split across ${chunks.length} pages successfully!\nUse Ctrl+Left/Right to navigate between pages.`);
  
  return chunks.length;
}

/* ======= Settings ======= */
let userPrefs = {
  maxLinesPerPage: 25,
  maxWordsPerLine: 10,
  activePalette: 'pastel'
};

function loadPrefs() {
  try {
    const stored = JSON.parse(localStorage.getItem("whiteboard-prefs"));
    if (stored) {
      userPrefs = { ...userPrefs, ...stored };
      activePalette = userPrefs.activePalette || 'pastel';
    }
  } catch(e) { console.warn("Prefs load failed", e); }
}

function savePrefs() {
  userPrefs.activePalette = activePalette;
  localStorage.setItem("whiteboard-prefs", JSON.stringify(userPrefs));
}

loadPrefs();

/* ======= Color Palette Functions ======= */
function updatePalettePreview() {
  const selectedPalette = document.getElementById("color-palette-select").value;
  const previewContainer = document.getElementById("palette-preview");
  const previewColors = document.getElementById("palette-preview-colors");
  
  if (selectedPalette === 'none') {
    previewContainer.style.display = 'none';
  } else {
    previewContainer.style.display = 'block';
    previewColors.innerHTML = '';
    
    const palette = colorPalettes[selectedPalette];
    if (palette) {
      palette.colors.forEach(color => {
        const colorDiv = document.createElement('div');
        colorDiv.className = 'palette-preview-color';
        colorDiv.style.backgroundColor = color;
        colorDiv.title = color;
        previewColors.appendChild(colorDiv);
      });
    }
  }
}

function updateToolbarPalette() {
  const paletteContainer = document.getElementById("color-palette");
  const paletteColors = document.getElementById("palette-colors");
  
  if (activePalette === 'none' || !colorPalettes[activePalette]) {
    paletteContainer.classList.add('hidden');
    selectedPaletteColor = null;
  } else {
    paletteContainer.classList.remove('hidden');
    paletteColors.innerHTML = '';
    
    const palette = colorPalettes[activePalette];
    palette.colors.forEach((color, index) => {
      const colorDiv = document.createElement('div');
      colorDiv.className = 'palette-color';
      colorDiv.style.backgroundColor = color;
      colorDiv.title = color;
      colorDiv.dataset.color = color;
      
      colorDiv.addEventListener('click', () => {
        selectPaletteColor(color, colorDiv);
      });
      
      paletteColors.appendChild(colorDiv);
    });
  }
}

function selectPaletteColor(colorValue, colorElement) {
  // Remove active class from all palette colors
  document.querySelectorAll('.palette-color').forEach(el => {
    el.classList.remove('active');
  });
  
  // Add active class to selected color
  colorElement.classList.add('active');
  selectedPaletteColor = colorValue;
  
  // Update the main color picker and current color
  color = colorValue;
  document.getElementById('color-picker').value = colorValue;
  document.getElementById('current-tool-color').style.backgroundColor = colorValue;
  
  // Save color to current tool's memory
  if (toolColors[currentTool]) {
    toolColors[currentTool] = colorValue;
  }
  
  applyColorToSelection(colorValue);
}

const settingsBtn = document.getElementById("settings-btn");
const settingsOverlay = document.getElementById("settings-overlay");
const settingsSave = document.getElementById("settings-save");
const settingsCancel = document.getElementById("settings-cancel");

settingsBtn.addEventListener("click", () => {
  document.getElementById("max-lines-per-page").value = userPrefs.maxLinesPerPage;
  document.getElementById("max-words-per-line").value = userPrefs.maxWordsPerLine;
  document.getElementById("color-palette-select").value = activePalette;
  updatePalettePreview();
  settingsOverlay.style.display = "flex";
});

settingsCancel.addEventListener("click", () => {
  settingsOverlay.style.display = "none";
});

// Info Button - Keyboard Shortcuts
const infoBtn = document.getElementById("info-btn");
const shortcutsOverlay = document.getElementById("shortcuts-overlay");
const shortcutsClose = document.getElementById("shortcuts-close");

infoBtn.addEventListener("click", () => {
  shortcutsOverlay.style.display = "flex";
});

shortcutsClose.addEventListener("click", () => {
  shortcutsOverlay.style.display = "none";
});

// Close shortcuts modal when clicking outside
shortcutsOverlay.addEventListener("click", (e) => {
  if (e.target === shortcutsOverlay) {
    shortcutsOverlay.style.display = "none";
  }
});

// Add event listener for palette selection preview
document.getElementById("color-palette-select").addEventListener("change", updatePalettePreview);

// Objects/Layers Modal
const objectsBtn = document.getElementById("objects-btn");
const objectsOverlay = document.getElementById("objects-overlay");
const objectsClose = document.getElementById("objects-close");
const layerSelect = document.getElementById("layer-select");
const objectsList = document.getElementById("objects-list");

objectsBtn.addEventListener("click", () => {
  populateLayers();
  populateObjects();
  objectsOverlay.style.display = "flex";
});

objectsClose.addEventListener("click", () => {
  objectsOverlay.style.display = "none";
});

// Close objects overlay when clicking outside
objectsOverlay.addEventListener("click", (e) => {
  if (e.target === objectsOverlay) {
    objectsOverlay.style.display = "none";
  }
});

layerSelect.addEventListener("change", () => {
  populateObjects();
});

// Function to populate layer dropdown
function populateLayers() {
  const layers = new Set();
  objects.forEach(obj => layers.add(obj.layer));
  
  // Clear existing options except "All Layers"
  while (layerSelect.options.length > 1) {
    layerSelect.remove(1);
  }
  
  // Add layer options
  Array.from(layers).sort((a, b) => a - b).forEach(layer => {
    const option = document.createElement("option");
    option.value = layer;
    option.textContent = `Layer ${layer}`;
    layerSelect.appendChild(option);
  });
}

// Function to populate objects list
function populateObjects() {
  const selectedLayer = layerSelect.value;
  const filteredObjects = selectedLayer === "all" 
    ? objects 
    : objects.filter(obj => obj.layer == selectedLayer);
  
  objectsList.innerHTML = "";
  
  if (filteredObjects.length === 0) {
    objectsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No objects found in this layer</div>';
    return;
  }
  
  filteredObjects.forEach(obj => {
    const objDiv = document.createElement("div");
    objDiv.style.cssText = `
      padding: 10px;
      border-bottom: 1px solid #e5e7eb;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
    `;
    
    objDiv.addEventListener("click", () => {
      selectObject(obj.id);
      objectsOverlay.style.display = "none";
    });
    
    objDiv.addEventListener("mouseenter", () => {
      objDiv.style.backgroundColor = "#f3f4f6";
    });
    
    objDiv.addEventListener("mouseleave", () => {
      objDiv.style.backgroundColor = "";
    });
    
    // Object icon based on type
    let icon = "";
    let typeLabel = "";
    const strokeType = obj.props?.strokeType || obj.strokeType;
    
    switch (obj.type) {
      case "stroke":
        // Show specific stroke type instead of generic "Stroke"
        switch (strokeType) {
          case "pen":
            icon = "fas fa-pen";
            typeLabel = "Pen";
            break;
          case "highlighter":
            icon = "fas fa-highlighter";
            typeLabel = "Highlighter";
            break;
          case "marker":
            icon = "fas fa-marker";
            typeLabel = "Marker";
            break;
          case "line":
            icon = "fas fa-minus";
            typeLabel = "Line";
            break;
          case "rectangle":
            icon = "fas fa-square";
            typeLabel = "Rectangle";
            break;
          case "arrow":
            icon = "fas fa-arrow-right";
            typeLabel = "Arrow";
            break;
          case "roundedRectangle":
            icon = "fas fa-square";
            typeLabel = "Rounded Rectangle";
            break;
          case "decision":
            icon = "fas fa-diamond";
            typeLabel = "Decision";
            break;
          case "inputOutput":
            icon = "fas fa-exchange-alt";
            typeLabel = "Input/Output";
            break;
          case "connector":
            icon = "fas fa-link";
            typeLabel = "Connector";
            break;
          default:
            icon = "fas fa-pen";
            typeLabel = "Stroke";
        }
        break;
      case "text":
        icon = "fas fa-font";
        typeLabel = "Text";
        break;
      case "image":
        icon = "fas fa-image";
        typeLabel = "Image";
        break;
      default:
        icon = "fas fa-square";
        typeLabel = obj.type;
    }
    
    // Object properties - handle both new format (obj.props) and legacy format (obj.property)
    let properties = [];
    const getProp = (propName) => obj.props?.[propName] ?? obj[propName];
    
    if (obj.type === "stroke") {
      properties.push(`Color: ${getProp('color') || '#000000'}`);
      properties.push(`Size: ${getProp('size') || 2}`);
      properties.push(`Points: ${getProp('path')?.length || 0}`);
    } else if (obj.type === "text") {
      const text = getProp('text') || '';
      properties.push(`Text: "${text.substring(0, 20)}${text.length > 20 ? '...' : ''}"`);
      properties.push(`Size: ${getProp('fontSize') || 24}`);
      properties.push(`Color: ${getProp('color') || '#000000'}`);
    } else if (obj.type === "image") {
      properties.push(`Position: (${Math.round(getProp('x') || 0)}, ${Math.round(getProp('y') || 0)})`);
    }
    
    objDiv.innerHTML = `
      <i class="${icon}" style="width: 20px; color: #6b7280;"></i>
      <div style="flex: 1;">
        <div style="font-weight: bold; color: #374151;">${typeLabel} #${obj.id}</div>
        <div style="font-size: 12px; color: #6b7280;">
          Layer: ${obj.layer} | ${properties.join(' | ')}
        </div>
      </div>
      <i class="fas fa-chevron-right" style="color: #9ca3af;"></i>
    `;
    
    objectsList.appendChild(objDiv);
  });
}

// Function to select an object
function selectObject(objId) {
  selectedId = objId;
  s('select'); // Switch to select tool
  redraw();
}

// Initialize palette on page load
document.addEventListener("DOMContentLoaded", () => {
  updateToolbarPalette();
});

settingsSave.addEventListener("click", () => {
  const maxLines = parseInt(document.getElementById("max-lines-per-page").value, 10) || 25;
  const maxWords = parseInt(document.getElementById("max-words-per-line").value, 10) || 10;
  const selectedPalette = document.getElementById("color-palette-select").value;
  
  userPrefs.maxLinesPerPage = maxLines;
  userPrefs.maxWordsPerLine = maxWords;
  
  // Update active palette
  activePalette = selectedPalette;
  updateToolbarPalette();
  
  savePrefs();
  settingsOverlay.style.display = "none";
});

/* ======= Utility Functions ======= */
function autoWrapTextByChars(text, maxChars) {
  if (!maxChars || maxChars <= 0) return text;

  return text
    .split("\n")
    .map(paragraph => {
      let result = [];
      for (let i = 0; i < paragraph.length; i += maxChars) {
        result.push(paragraph.slice(i, i + maxChars));
      }
      return result.join("\n");
    })
    .join("\n");
}

function autoWrapTextByWords(text, maxWords) {
  if (!maxWords || maxWords <= 0) return text;

  return text
    .split("\n")
    .map(paragraph => {
      // Handle empty lines
      if (paragraph.trim() === '') return paragraph;
      
      const words = paragraph.split(/\s+/).filter(word => word.length > 0);
      if (words.length === 0) return paragraph;
      
      let result = [];
      for (let i = 0; i < words.length; i += maxWords) {
        result.push(words.slice(i, i + maxWords).join(" "));
      }
      return result.join("\n");
    })
    .join("\n");
}

/* ======= Keyboard Shortcuts for Pages ======= */
document.addEventListener('keydown', (e) => {
  // Page navigation shortcuts (Ctrl+Left/Right)
  if (e.ctrlKey && !e.shiftKey && !e.altKey) {
    if (e.key === 'ArrowLeft' && currentPageIndex > 0) {
      e.preventDefault();
      switchToPage(currentPageIndex - 1);
    } else if (e.key === 'ArrowRight' && currentPageIndex < pages.length - 1) {
      e.preventDefault();
      switchToPage(currentPageIndex + 1);
    } else if (e.key === 'Enter') {
      // Ctrl+Enter to add new page
      e.preventDefault();
      addNewPage();
    }
  }
});

/* ======= Mouse Wheel for Page Navigation ======= */
document.addEventListener('wheel', (e) => {
  const textModalOpen = textEditorOverlay && textEditorOverlay.style.display === 'flex';
  if (textModalOpen) return;
  // Only handle wheel when not zooming (Ctrl not pressed) and not in input fields or toolbar (toolbar should scroll itself)
  const insideToolbar = e.target.closest && e.target.closest('#board-toolbar');
  if (!e.ctrlKey && !insideToolbar && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT') {
    if (e.deltaY > 0 && currentPageIndex < pages.length - 1) {
      e.preventDefault();
      switchToPage(currentPageIndex + 1);
    } else if (e.deltaY < 0 && currentPageIndex > 0) {
      e.preventDefault();
      switchToPage(currentPageIndex - 1);
    }
  }
});

// Allow vertical wheel on the toolbar to scroll it horizontally instead of flipping pages
const toolbar = document.getElementById('board-toolbar');
if (toolbar) {
  const toolbarScroller = toolbar.querySelector('.overflow-x-auto');
  toolbar.addEventListener('wheel', (e) => {
    if (toolbarScroller && toolbarScroller.scrollWidth > toolbarScroller.clientWidth) {
      toolbarScroller.scrollLeft += e.deltaY;
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive: false });
}

/* ======= Self-tests ======= */
(function runSelfTests(){
  try{
    const circle={id:999,type:'stroke',layer:0,props:{color:'#000',size:8,path:[]}};
    const cx=200, cy=200, r=80; 
    for(let a=0;a<=360;a+=10){ 
      const th=a*Math.PI/180; 
      circle.props.path.push({x:cx+r*Math.cos(th), y:cy+r*Math.sin(th)}); 
    }
    const line={id:1000,type:'stroke',layer:1,props:{color:'#000',size:6,path:[{x:170,y:200},{x:230,y:200}]}}
    const ptInsideCircleNotOnStroke={x:200,y:200};
    const ptOnLine={x:200,y:200};
    const was=objects; objects=[circle,line];
    const hit1=pickTopMost(ptInsideCircleNotOnStroke);
    const ok1 = hit1 && hit1.id===1000;
    const ptOnCircle={x:cx+r,y:cy};
    const hit2=pickTopMost(ptOnCircle);
    const ok2 = hit2 && hit2.id===999;
    objects=was; redraw();  
    console.log('[multi-page whiteboard tests] hit-inside-circle->line:', ok1, ' hit-on-circle->circle:', ok2);    
  }catch(err){ console.warn('Self tests failed', err); }})();/* ======= Initialize ======= */
updateCursor();
redraw();

// Initialize color indicator
document.getElementById('current-tool-color').style.backgroundColor = color;

// Initialize size control
document.getElementById('size-range').value = size;

// Update page title when board title changes
document.getElementById('board-title').addEventListener('input', function() {
  const title = this.value || 'Miopage';
  document.title = title + ' - Miopage';
});

// Set initial page title
document.addEventListener('DOMContentLoaded', function() {
  const initialTitle = document.getElementById('board-title').value || 'Miopage';
  document.title = initialTitle + ' - Miopage';
});

// Dropdown menu functionality
document.addEventListener('DOMContentLoaded', function() {
    const fileMenuBtn = document.getElementById('file-menu-btn');
    const fileMenu = document.getElementById('file-menu');
    
    // Toggle dropdown
    fileMenuBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        
        // Position the dropdown relative to the button
        const rect = fileMenuBtn.getBoundingClientRect();
        fileMenu.style.top = (rect.bottom + 5) + 'px';
        fileMenu.style.right = (window.innerWidth - rect.right) + 'px';
        
        fileMenu.classList.toggle('hidden');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', function() {
        fileMenu.classList.add('hidden');
    });
    
    // Prevent dropdown from closing when clicking inside
    fileMenu.addEventListener('click', function(e) {
        e.stopPropagation();
    });
});

// Shapes dropdown functionality
document.addEventListener('DOMContentLoaded', function() {
    const shapesBtn = document.getElementById('shapes-btn');
    const shapesDropdown = document.getElementById('shapes-dropdown');
    
    // Toggle dropdown
    shapesBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        
        // Close text boxes dropdown if open
        const textboxesDropdown = document.getElementById('textboxes-dropdown');
        if (textboxesDropdown) {
            textboxesDropdown.classList.add('hidden');
        }
        
        // Position the dropdown relative to the button
        const rect = shapesBtn.getBoundingClientRect();
        shapesDropdown.style.top = (rect.bottom + 5) + 'px';
        shapesDropdown.style.left = rect.left + 'px';
        
        shapesDropdown.classList.toggle('hidden');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', function() {
        shapesDropdown.classList.add('hidden');
    });
    
    // Prevent dropdown from closing when clicking inside
    shapesDropdown.addEventListener('click', function(e) {
        e.stopPropagation();
    });
});

// Text Boxes dropdown functionality
document.addEventListener('DOMContentLoaded', function() {
    const textboxesBtn = document.getElementById('textboxes-btn');
    const textboxesDropdown = document.getElementById('textboxes-dropdown');
    
    // Toggle dropdown
    textboxesBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        
        // Close shapes dropdown if open
        const shapesDropdown = document.getElementById('shapes-dropdown');
        if (shapesDropdown) {
            shapesDropdown.classList.add('hidden');
        }
        
        // Position the dropdown relative to the button
        const rect = textboxesBtn.getBoundingClientRect();
        textboxesDropdown.style.top = (rect.bottom + 5) + 'px';
        textboxesDropdown.style.left = rect.left + 'px';
        
        textboxesDropdown.classList.toggle('hidden');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', function() {
        textboxesDropdown.classList.add('hidden');
    });
    
    // Prevent dropdown from closing when clicking inside
    textboxesDropdown.addEventListener('click', function(e) {
        e.stopPropagation();
    });
});

// Support for iframe embedding
(function setupIframeSupport() {
    // Check if we're embedded in an iframe
    const isEmbedded = window.self !== window.top;
    
    if (isEmbedded) {
        console.log('Running in iframe mode');
        
        // Listen for requests from parent window
        window.addEventListener('message', function(event) {
            if (event.data && event.data.action === 'getBoardData') {
                console.log('Parent requested board data');
                
                // Save current page state before sending
                saveCurrentPageState();
                
                // Prepare board data in the same format as save
                const boardData = {
                    version: 3,
                    pages: pages,
                    currentPageIndex: currentPageIndex,
                    nextPageId: nextPageId,
                    nextObjectId: nextObjectId
                };
                
                // Send data back to parent
                window.parent.postMessage({
                    action: 'boardData',
                    data: boardData
                }, '*');
                
                console.log('Sent board data to parent:', boardData);
            } else if (event.data && event.data.action === 'loadBoardData') {
                console.log('Parent sent board data to load:', event.data.data);
                
                try {
                    const boardData = event.data.data;
                    
                    // Load the board data
                    if (boardData && boardData.pages && Array.isArray(boardData.pages)) {
                        pages = boardData.pages.map(page => ({
                            id: page.id,
                            objects: page.objects || [],
                            undoStack: page.undoStack || [],
                            redoStack: page.redoStack || []
                        }));
                        currentPageIndex = Math.max(0, Math.min(boardData.currentPageIndex || 0, pages.length - 1));
                        nextPageId = boardData.nextPageId || (pages.reduce((m,p)=>Math.max(m,p.id||0),0)+1) || 1;
                        nextObjectId = boardData.nextObjectId || 1;
                        
                        if (pages.length === 0) {
                            pages = [createNewPage()];
                            currentPageIndex = 0;
                        }
                        
                        loadPageState(currentPageIndex);
                        updatePageControls();
                        
                        console.log('Successfully loaded board data in iframe');
                    }
                } catch (e) {
                    console.error('Error loading board data in iframe:', e);
                }
            } else if (event.data && event.data.action === 'togglePreview') {
                console.log('Parent toggled preview mode:', event.data.previewMode);
                
                // Toggle preview mode in the iframe
                if (event.data.previewMode) {
                    document.body.classList.add('preview-mode');
                } else {
                    document.body.classList.remove('preview-mode');
                }
            }
        });
        
        // Optionally hide or modify certain UI elements when embedded
        // For example, you might want to hide the "Save" button since saving is handled by parent
        // document.getElementById('save-btn').style.display = 'none';
    }
})();

// ============================================================================
// AUTO-SAVE IMPLEMENTATION
// ============================================================================

/**
 * Start auto-save timer
 * Saves automatically every 45 seconds if there are unsaved changes
 */
function startAutoSave() {
    // Clear any existing timer
    if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
    }
    
    // Set up auto-save every 45 seconds
    autoSaveTimer = setInterval(function() {
        if (hasUnsavedChanges && !isSaving) {
            console.log('[AUTO-SAVE] Detected unsaved changes, saving...');
            saveToServer().then(function() {
                hasUnsavedChanges = false;
                console.log('[AUTO-SAVE] Save completed successfully');
            }).catch(function(error) {
                console.error('[AUTO-SAVE] Save failed:', error);
            });
        }
    }, 45000); // 45 seconds
    
    console.log('[AUTO-SAVE] Auto-save enabled (45 second intervals)');
}

/**
 * Stop auto-save timer
 */
function stopAutoSave() {
    if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
        autoSaveTimer = null;
        console.log('[AUTO-SAVE] Auto-save disabled');
    }
}

// Start auto-save when page loads (only if board exists)
{% if board and not public_view %}
startAutoSave();
{% endif %}

// ============================================================================
// UNSAVED CHANGES WARNING
// ============================================================================

/**
 * Warn user before leaving page with unsaved changes
 */
window.addEventListener('beforeunload', function(e) {
  if (!IS_PUBLIC_VIEW && hasUnsavedChanges && !isSaving) {
        // Modern browsers ignore custom messages, but we still need to set returnValue
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
    }
});

/**
 * Clear unsaved changes flag after successful save
 * Wrap the existing saveToServer to mark as saved
 */
if (typeof saveToServer === 'function') {
    const originalSaveToServer = saveToServer;
    
    saveToServer = async function() {
        isSaving = true;
        try {
            await originalSaveToServer();
            hasUnsavedChanges = false;
            console.log('[SAVE] Unsaved changes flag cleared');
        } catch (error) {
            console.error('[SAVE] Error during save:', error);
            throw error;
        } finally {
            isSaving = false;
        }
    };
}

// ============================================================================
// UNDO HISTORY LIMIT ENFORCEMENT
// ============================================================================

/**
 * Enforce undo history limit on page state save
 * This prevents memory bloat during long editing sessions
 */
const originalSaveCurrentPageState = saveCurrentPageState;
saveCurrentPageState = function() {
    // Call original function
    originalSaveCurrentPageState();
    
    // Enforce history limit on current page
    if (pages[currentPageIndex]) {
        const page = pages[currentPageIndex];
        
        if (page.undoStack && page.undoStack.length > MAX_UNDO_HISTORY) {
            const removed = page.undoStack.length - MAX_UNDO_HISTORY;
            page.undoStack = page.undoStack.slice(-MAX_UNDO_HISTORY);
            console.log(`[UNDO-LIMIT] Trimmed ${removed} old undo actions from page ${currentPageIndex + 1}`);
        }
        
        // Also limit redo stack
        if (page.redoStack && page.redoStack.length > MAX_UNDO_HISTORY) {
            const removed = page.redoStack.length - MAX_UNDO_HISTORY;
            page.redoStack = page.redoStack.slice(-MAX_UNDO_HISTORY);
            console.log(`[UNDO-LIMIT] Trimmed ${removed} old redo actions from page ${currentPageIndex + 1}`);
        }
    }
};

console.log('[INIT] Auto-save, unsaved changes warning, and undo history limit (max 50) initialized');

</script>
</body>
</html>